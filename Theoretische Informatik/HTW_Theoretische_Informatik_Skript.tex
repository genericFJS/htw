% Header aus der Vorlage
\input{../LaTeX_master/LaTeX_master_HTW}

\bibliography{../Literatur/HTW_Literatur.bib}

% Definition von Titel, Autor usw.
\DTitel{Theoretische Informatik}
\DUntertitel{Vorlesungsskript}
\DAutor{Falk-Jonatan Strube}
\DNotiz{Vorlesung von Dr. Boris Hollas}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\chapter*{Inhalte}
Grundlage: Grundkurs Theoretische Informatik \cite{hollas2015grundkurs}
\begin{itemize}
\item Formale Sprachen
\begin{itemize}
\item Reguläre Sprachen
\begin{itemize}
\item Endliche Automaten
\item Reguläre Ausdrücke
\end{itemize}
\item Nichtreguläre Sprachen
\item Kontextfreie Sprachen
\begin{itemize}
\item Kellerautomaten
\item Grammatiken
\end{itemize}
\end{itemize}
\item Berechenbarkeit
\begin{itemize}
\item Halteproblem
\end{itemize}
\item Komplexitätsklassen
\begin{itemize}
\item $P$
\item $NP$
\item $NP$-vollständige Probleme
\end{itemize}
\end{itemize}

\chapter{Automaten und Formale Sprachen}
%\section{Formale Sprachen}
\paragraph{Def.:} Ein Alphabet ist eine Menge $\Sigma \not = \emptyset$ (Symbole in $\Sigma$ -- müssen nicht einzelne Buchstaben sein, auch Wörter usw. [bspw. „if“ oder „else“ im Alphabet der Programmiersprache C]).

\paragraph{Def.:} Für $w_1, ..., w_n \in \Sigma$ ist $w=w_1...w_n$ ein Wort der Länge $n$.\\
$\Sigma^n$ beschreibt alle Worte mit der Länge genau $n$\\
Das Wort $\varepsilon$ ist das \emph{leere Wort}.\\
Die Menge aller Wörter bezeichnen wir mit $\Sigma^*$ (einschließlich dem leeren Wort).

\subparagraph{Bsp.:} $\Sigma = \{a,b,c\}\quad \rightarrow \Sigma^*=\{\varepsilon, a, b, c, aa, ab,a c, aaa, ...\}$
\paragraph{Def.:} Für Wörter $a,b \in \Sigma^*$ ist $ab$ die Konkatenation dieser Wörter.\\
Für ein Wort $w$ ist $w^n$ die $n$-fache Konkatenation von $w$, wobei $w^0=\varepsilon$.

\subparagraph{Bemerkung:} Für alle $w \in \Sigma^*$ gilt $\varepsilon w = w = w \varepsilon$. $\varepsilon$ ist also das neutrale Element der Konkatenation.

\paragraph{Def.:} Eine \emph{formale Sprache} ist eine Teilmenge von $\sigma^*$.

\paragraph{Def.:} Für Sprachen $A, B$ ist $AB=\{ab \;|\; a \in A, \; b \in B\}$ sowie $A^n=\prod_{i=1}^{n}A$, wobei $A^0=\{\varepsilon\}$.
\subparagraph{Bemerkung:} $\emptyset, \varepsilon, \{\varepsilon\}$ sind unterschiedliche Dinge (leere Menge, leeres Wort, Menge mit leerem Wort).

\subparagraph{Bemerkung:} $\Sigma^*$ lässt sich ebenfalls definieren durch $\Sigma^*=\bigcup_{n\geq 0}\Sigma^n$.\\
Ferner ist $\Sigma^+=\Sigma^*-\{\varepsilon\}$.

\section{Reguläre Sprachen}
\subsection{Deterministische endliche Automaten (DFA)}
\subparagraph{Bsp.:} \parskp
\begin{tikzpicture}[-latex,shorten >= .3em,shorten <= .3em,auto,node distance=6em]
%\node[initial,state]		(A)	{$q_a$};
%\node[state]	(B) [above right of=A] {$q_b$};

%\path (A) edge		node {0} (B)
\node[initial, initial text =, state] (z0) {$z_0$};
\node[state] (z1) [right of=z0] {$z_1$};
\node[state] (z2) [right of=z1] {$z_2$};
\node[state, double, double distance = .5mm] (zE) [right of=z2] {$z_E$};
\path (z0) edge [loop above] node{$b,c$} (z0);
\path (z1) edge [loop above] node{$a$} (z1);
\path (zE) edge [loop above] node{$a,b,c$} (zE);
\path (z0) edge [bend left=20] node{$a$} (z1);
\path (z1) edge [bend left=20] node{$c$} (z0);
\path (z1) edge [bend left=20] node{$b$} (z2);
\path (z2) edge [bend left=20] node{$a$} (z1);
\path (z2) edge [bend left = 35] node{$b$} (z0);
\path (z2) edge node{$c$} (zE);
\end{tikzpicture}\\
(Pfeil zeigt auf Startzustand, Endzustand ist doppelt umrandet)\\
Dieser DFA akzeptiert alle Wörter über $\Sigma = \{a,b,c\}$, die $abc$ enthalten.\\
Deterministisch: Es gibt genau ein Folgezustand. Von jedem Knoten aus gibt es genau eine Kante für jedes Zeichen, nicht mehrere und nicht keine.
\subparagraph{Bsp.:} \parskp
\begin{tikzpicture}[-latex,shorten >= .3em,shorten <= .3em,auto,node distance=6em]
%\node[initial,state]		(A)	{$q_a$};
%\node[state]	(B) [above right of=A] {$q_b$};

%\path (A) edge		node {0} (B)
\node[initial, initial text = , state, double, double distance = .5mm] (zE){};
\path (z0) edge [loop above] node{$a,b,c$} (zE);
\end{tikzpicture}\\
Dieser DFA erkennt die Sprache $\{a,b,c\}^*$.
\paragraph{Def.:} Ein DFA ist ein Tupel $\mathcal{M}=(Z, \Sigma, \delta, z_0, E)$
\begin{itemize}
\item $Z$: Menge der Zustände
\item $\Sigma$: Eingabealphabet
\item $\delta$: Überführungsfunktion $Z\times \Sigma \rightarrow Z$. Dabei bedeutet $\delta (z,a) = z'$, dass $\mathcal{M}$ im Zustand $z$ für das Zeichen $a$ in den Zustand $z'$ wechselt.
\item $z_0\in Z$: Startzustand
\item $E$: Menge der Endzustände
\end{itemize}
$\delta$: \\
\begin{tikzpicture}[-latex,shorten >= .3em,shorten <= .3em,auto,node distance=6em]
%\node[initial,state]		(A)	{$q_a$};
%\node[state]	(B) [above right of=A] {$q_b$};

%\path (A) edge		node {0} (B)
\node[initial, state] (z0) {$z$};
\node[state] (z1) [right of=z0] {$z'$};
\path (z0) edge [bend left=20] node{$a$} (z1);
\end{tikzpicture}

\paragraph{Def.:} Die erweiterte Überführungsfunktion $\hat{\delta}:Z\times \Sigma^*\rightarrow Z$ ist definiert durch\\
$\hat{\delta}(z,w)=\begin{cases}
z & \text{für }w = \varepsilon\\
\hat{\delta}(\delta(z,a),x) & \text{für }w=ax \text{ mit } a\in \Sigma ,x \in \Sigma^*
\end{cases}$\\
Dazu vergleichbarer C-Code:
\begin{lstlisting}[language=C]
int $\hat{\delta}$(int z, char* w){
	if ( strlen(w) == 0 )
		return z;
	else
		return $\hat{\delta}$($\delta$(z, w[0]), w[1]);
\end{lstlisting}
Veranschaulichung:\\
ABB4\\
Die erweiterte Überführungsfunktion bestimmt den Zustand nach dem vollständingen Lesen eines Wortes.

\subparagraph{Bsp.:} \parskp
ABB5
\begin{align*}
\hat{\delta}(z_0, aaba) &= \hat{\delta}(\delta(z_0,a),aba)=\\
\hat{\delta}(z_0, aba) &= \hat{\delta}(\delta(z_0,a),ba)=\\
\hat{\delta}(z_0, ba) &= \hat{\delta}(\delta(z_0,b),a)=\\
\hat{\delta}(z_E, a) &= \hat{\delta}(\delta(z_E,a), \varepsilon)=\\
\hat{\delta}(z_E, \varepsilon) &= z_E\\
\end{align*}
Die von $\mathcal{M}$ \emph{akzeptierte Sprache} ist $L(\mathcal{M})=\{w\in \Sigma^* \;|\; \hat{\delta}(z_0, w) \in E\}$

\subsection{Nichtdeterministischer endliche Automaten (NFA)}
ABB23\\
NFA, der alles akzeptiert, was $abc$ enthält:\\
ABB24\\
Beispiel: Wort $abaabcab$
\subparagraph{Beispiel:} NFA, der alle Wörter akzeptiert, die auf $001$ enden:\\
ABB25\\
Akzeptierte Worte unter anderem: $01011001$, $001001$\\
Ein Wort wird vom NFA akzeptiert, wenn es einen Weg, ausgehend von einem Startzustand, gibt, mit den ein End-Zustand erreicht wird.\\
Der NFA „weiß“ nicht, welcher Pfad zu durchlaufen ist; diesen muss der Benutzer ermitteln (wie bei einer Straßenkarte).\\
Ein NFA lässt sich formalisieren durch ein Tupel $\mathcal{M}=(Z, \Sigma, \delta, S, E)$
\begin{itemize}
\item $Z$: Zustände
\item $\Sigma$: Eingabealphabet
\item $\delta$: $Z \times \Sigma \to \mathcal{P}(Z)$ Überführungsfunktion (bildet ab in Potenzmenge von $Z$)
\item $S$: Menge der Startzustände
\item $E$: Menge der Endzustände
\end{itemize}
Dabei bedeutet $\delta(z,a)\ni z'$, dass der NEA im Zustand $z$ für die Eingabe $a$ die Möglichkeit besitzt, in den Zustand $z'$ zu wechseln.

\subsection{Umwandlung eines NFA in einen DFA}\parskp
Wir wollen den NFA\\
ABB 27\\
in einen DFA umwandeln. Der Startzustand des DFA besteht aus den Startzuständen des NFA:\\
ABB 28\\
Betrachten die Folgezustände für $a \in \Sigma$:\\
ABB 29\\
nächster Schritt:\\
ABB 30\\
nächster Schritt:\\
ABB 31\\
weitere Schritte:\\
$z_0,b: \{z_0\}$\\
$z_1,b: \{z_2\}$\\
ABB 32\\
$z_0,c: \{z_0\}$\\
$z_1,c: \{\}$\\
ABB 33\\
usw.:\\
ABB 34\\
Wenn ein Zustand des DFA einen Endzustand des NFA enthält, so ist es ein Endzustand.\\
Der auf diese Weise erhaltene DFA kann Zustände enthalten, die sich zu einem Zustand zusammen fassen lassen. Mit dem Algorithmus Minimalautomat lässt sich ein DFA konstruieren, der minimal bezüglich der Anzahl seiner Zustände ist. Der Minimalautomat ist eindeutig, d.h. Minimalautomaten unterscheiden sich höchstens in der Benennung der Zustände.

\subsection{Reguläre Ausdrücke}
\paragraph{Def.:} Sei $\Sigma$ ein Alphabet. Ein \emph{regulärer Ausdruck} $E$ sowie die durch $E$ \emph{erzeugte Sprache $L(E)$} sind induktiv definiert:
\begin{itemize}
\item $\emptyset$ ist ein regulärer Ausdruck und $L(\emptyset)=\emptyset$.\\
Bsp.: \\
ABB35
\item Für $a \in \Sigma \cup \{\varepsilon\}$ ist $a$ ein regulärer Ausdruck und $L(a)=\{a\}$.
\item Für reguläre Ausdrücke $E_1, E_2$ sind $(E_1 | E_2), \; (E_1 E_2), \; (E_1^*)$ reguläre Ausdrücke (hier: $|=$„oder“) und $L(E_1|E_2)=L(E_1)\cup L(E_2), \; L(E_1E_2)=L(E_1)L(E_2), \; L(E_1^*)=L(E_1)^*$ die davon erzeugten Sprachen:\\
\begin{tabular}{l | r l}
Ausdruck & Sprache &\\
\hline
$E_1 | E_2$ & $L(E_1|E_2)$&$=L(E_1)\cup L(E_2)$\\
$E_1 E_2$ & $L(E_1E_2)$&$=L(E_1)L(E_2)$\\
$E_1^*$ & $L(E_1^*)$&$=L(E_1)^*$\\
\end{tabular}\medskip\\
Hinweis: $E^+=E E^*$, $E?=\varepsilon|E$\\
$\boxed{\text{Wenn }E_1, E_2 \text{ regulär, dann auch } (E_1 | E_2), \; (E_1 E_2), \; (E_1^*) \text{ regulär}}$
\end{itemize}
\subparagraph{Bsp.:} 
\begin{itemize}
\item $L( (0|1)^*) =(L(0|1))^*=(L(0)\cup L(1))^*=(\{0\}\cup\{1\})^*=\{0,1\}^*$
\item Regulärer Ausdruck über $\Sigma=\{a,b,c\}$, der die gleiche Sprache erzeugt wie der DFA aus dem letzten Automaten-Beispiel:\\
$L((a|b|c)^*abc(a|b|c)^*)=\{a,b,c\}^*\{abc\}\{a,b,c\}^*$
\end{itemize}

\paragraph{Satz:} Reguläre Ausdrücke erzeugen genau die regulären Sprachen.
\subparagraph{Skizze:} Umwandlung eines regulären Ausdrucks in einen endlichen Automaten.
\begin{itemize}
\item $\emptyset$: ABB 40
\item $a \in \Sigma$: ABB 41 1.\\
$\varepsilon$: ABB 41 2.
\item Seien $E_1, E_2$ reguläre Ausdrücke und $\mathcal{M}_1, \mathcal{M}_2$ DFAs mit $L(E_1)=L(\mathcal{M}_1), L(E_2)=L(\mathcal{M}_2)$.
\begin{itemize}
\item $E_1 | E_2$: $\mathcal{M}_1, \mathcal{M}_2$ sind zusammen ein NFA, der $L(\mathcal{M}_1) \vee L(\mathcal{M}_2)$ erkennt.\\
Bsp.: $E_1=a, E_2=b$\\
ABB 42
\item $E_1 E_2$: $\mathcal{M}_1, \mathcal{M}_2$ müssen hintereinander geschaltet werden, wobei ggf. neue Kanten eingefügt werden müssen. Dazu betrachtet man die Kante nach der neuen Verbindung und erzeugt dem entsprechend die Übergangskanten.\\
ABB 43
\item $E_1^*$: Es müssen Kanten zurück zum Startzustand eingefügt werden\\
ABB 44
\end{itemize}
\end{itemize}
Der Beweis für die umgekehrte Richtung (DFA $\to$ reg. Ausdruck) ist schwierig.
\subparagraph{Bsp.:}
\begin{itemize}
\item $E=0(0|1)^*$\\
ABB 45
\item ABB 46\\
Beobachtungen:
\begin{itemize}
\item um zum Endzustand zu kommen, braucht man eine $1$.
\item vor der $1$ kann $\varepsilon$ stehen, oder beliebig viele $0$en der $1$en.
\end{itemize}
$\Rightarrow E=(0|1)^* 1$
\end{itemize}

\subsection{Das Pumping-Lemma}
Wenn ein DFA ein Wort akzeptiert, das mindestens so lang ist wie die Anzahl seiner Zustände, dann muss er einen Zustand zweimal durchlaufen (Schubfachprinzip). Daraus folgt, dass der DFA dabei eine Schleife durchläuft.
\subparagraph{Bsp.:}\parskp
ABB 47\\
Für $x=abcdecfg$ durchläuft der Automat eine Schleife: $x=ab\,\boxed{cde}\,cfg$. Daher akzeptiert der DFA auch alle Wärter $ab(cde)^k cfg$ für $k \geq 0$.
\paragraph{Satz:} (Pumping Lemma)\\
Für jede reguläre Sprache $L$ gibt es ein $n>0$ ($n$: Anzahl Zustände des Minimalautomaten), so dass es für alle Wörter $x \in L$ mit $|x|\geq n$ eine Zerlegung $x=uvw$ gibt (in vorherigem Bsp.: $u=ab, \; v=cde \; w =cfg$), so dass gilt:
\begin{enumerate}
\item $|v| \geq 1$
\item $|uv|\leq n$ \quad ($u, w$ können auch $\varepsilon$ sein)
\item $uv^kw \in L$ für alle $k\geq 0$.
\end{enumerate}
Ohne Einschränkung ist $n$ die Anzahl Zustände des Minimalautomaten.\\
$\Rightarrow \forall \text{ regulären Sprachen }L\quad \exists \;n>0 \quad\forall \; x \in L, \; |x| \geq n \quad \exists \;u,v,w \text{ mit }x=uvw \text{ und }|v| \geq 1,|uv|\geq n \quad \forall \; k\geq 0 \; uv^kw\in L$.\\
Das Pumping-Lemma lässt sich nutzen, um zu zeigen, dass eine Sprache nicht regulär ist.
\subparagraph{Bsp.:} Wir zeigen, dass $L=\{a^nb^n|n\in \mathbb{N}\}$ nicht regulär ist.\\
Problemstellung: Der Automat kann sich das $n$ nicht „merken“, um nach $n$ $a$s wieder $n$ $b$s zu erzeugen. \\
Beweis (Widerspruch):
\begin{itemize}
\item Angenommen, $L$ sei regulär.
\item Nach Pumping-Lemma gibt es dann ein $n>0$, so dass sich alle $x\in L$ mit $|x|\geq n$ gemäß Pumping-Lemma zerlegen lassen.
\item Sei $x=a^nb^n$. 
\item Angenommen $v$ enthalte ein $b$, dann wäre $|uv| > n$. \\
Aus $|uv|\leq n$ folgt aber, dass $v$ kein $b$ enthält. aus $|v|\geq 1$ folgt, dass $v$ mindestens ein $a$ enthält.\\
ABB 48
\item Das Wort $uw$ enthält daher weniger $a$s als $b$s und kann somit nicht in $L$ enthalten sein (denn $w$ enthält $b^n$, da $v$ mindestens ein $a$ enthält, ist durch $uw$ mindestens ein $a$ „verloren gegangen“: $uw=a^{n-|v|}b^n$) und ist deshalb nicht in $L$ enthälten, Widerspruch\,\lightning \; \#
\end{itemize}
Vorgehen:
\begin{itemize}
\item ist regulär
\item Def. Pumping Lemma
\item $x$ finden (gilt für alle $x$, also ein günstiges $x$ aussuchen, mit dem sich Beweis führen lässt)
\item durch 1.) und/oder 2.) einschränken
\item durch 3.) zum Widerspruch führen
\end{itemize}

\subparagraph{Bsp.:} Wir zeigen, dass $L=\{zz|z\in \{a,b\}^*\}$ nicht regulär ist.\\
Intuitiver Hinweis: Kann nicht regulär sein, da sich der Automat nicht merken kann, wie viele $a$s und $b$s im ersten $z$ gelesen wurden, um dann das gleiche im zweiten $z$ zu fabrizieren.\\
Beweis: 
\begin{itemize}
\item Angenommen, $L$ ist regulär.
\item Dann gibt es ein $n>0$, so dass sich alle $x \in L$ mit $|x|\geq n$ zerlegen lassen gemäß Pumping-Lemma.
\item Sei $x=a^nb a^nb$.
\item Wegen $|uv|\leq n$ und $|v|\geq 1$ besteht $v$ aus mindestens einem $a$.\\
ABB 61
\item Dann enthält $uw=a^{n-|v|}ba^nb$ (für $k=0$) weniger $a$s in der vorderen Hälfte als in der hinteren Hälfte. Da sich $uw$ deshalb nicht in die Form $zz$ mit $z\in \{a,b\}^*$ brigen lässt, ist $uw \not \in L$, Widerspruch!
\end{itemize}

\paragraph{Satz:} Seien $L$ regulär und $n$ die Anzahl Zustände des Minimalautomaten zu $L$. Dann gilt $|L| = \infty$ genau dann, wenn es ein $x \in L$ gibt mit $n\leq  |x| < 2n$.\\
Beweis:\\
($\Leftarrow$):\\
Gemäß Pumping Lemma gibt es eine Zerlegung $x=uvw$ mit $|v| \geq 1$ und $uv^kw\in L$ für alle $k \in \mathbb{N}_0$ ($\mathbb{N}$ ist unendlich).\\
Daraus folg $|L|=\infty$.\\
($\Rightarrow$):\\
Da es nur endlich viele Wörter $x$ mit $|x|<n$ gibt, gibt es ein $x\in L$ mit $|x|\geq n$.\\
Sei daher $x\in L$ mit $|x| \geq n$ und $|x|$ minimal.\\
Gemäß PL lässt sich $x$ zerlegen in $x=uvw$.\\
Da $uw \in L$ und $|x|$ minimal ist, gilt $|uw|<n$.\\
Wegen $|x|\geq \underbrace{|uv|}_{<n \text{ gemäß PL}}+\underbrace{|uw|}_{<n \text{ Satz zuvor}}<n+n=2n$ folgt die Behauptung $n \leq |x| \leq 2n$. \\
Regulärer Ausdruck: Generator\\
Automat: Validator
\section{Kontextfreie Sprachen}

\subsection{Kellerautomaten (PDA)}
Ein Kellerautomat (Pushdown Automaton, PDA) besitzt gegenüber einem NFA zwei zusätzliche Eigenschaften:
\begin{itemize}
\item Es gibt $\varepsilon$-Übergänge.
\item Er besitzt einen Stack, auf dem Zeichen abgelegt oder von dem Zeichen gelesen werden können.
\end{itemize}
Zur graphischen Darstellung von PDAs verwenden wir eine erweiterte Automatennotation:\\
ABB62\\
Unten auf dem Stack liegt das Symbol \#. Dies ist das einzige Symbol, das sich zu Beginn einer Rechnung auf dem Stack befindet.
\subparagraph{Bsp.:} PDA, der $\{a^nb^n|n\in \mathbb{N}\}$ akzeptiert.\\
ABB63\\
Wir erlauben nun, dass der PDA in einem Schritt auch mehrere Zeichen auf den Stack schreibt. Dazu erweitern wir die graphische Notation wie folgt:\\
ABB 68
\subparagraph{Def.:} Ein PDA ist ein Tupel $M=(Z,\Sigma, \Gamma, \delta, z_0, \#, E)$
\begin{itemize}
\item $Z$: Zustände
\item $\Sigma$: Eingabealphabet
\item $\Gamma$: Stackalphabet
\item $\delta$:
\item $z_0\in Z$: Startzustand
\item $\# \in \Gamma$: Unterstes Stackzeichen
\item $E \in Z$: Endzustände
\end{itemize}
ABB 69\\
$a \in \Sigma \cup \{\varepsilon\}$\\
$\gamma \in \Gamma \cup \{\varepsilon\}$\\
$\gamma' \in \Gamma \cup \{\varepsilon\}$


\newpage
\printbibliography
\end{document}
