% Header aus der Vorlage
\input{../LaTeX_master/LaTeX_master_HTW}

%\bibliography{../Literatur/HTW_Literatur.bib}

% Definition von Titel, Autor usw.
\DTitel{Datenbanksysteme I}
\DUntertitel{Vorlesungsskript}
\DAutor{Falk-Jonatan Strube}
\DNotiz{Vorlesung von Dr. Axel Toll}

\newcommand{\folie}[2]{\begin{center}
\includegraphics[page=#2]{Vorlesung/oneperpage/Kap#1.pdf}
\end{center}}
\newcommand{\Folie}[2]{\begin{center}
\includegraphics[page=#2, height=9.63cm]{Vorlesung/oneperpage/Kap#1.pdf}
\end{center}}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\chapter*{Prüfungsmodalitäten}
\paragraph{PVL} unbenoteter Beleg als Voraussetzung zur Prüfung
\begin{enumerate}
\item Access-Beleg (in Papier-Form abzugeben bis 27.05.2016)
\item Abnahme der SQL-Praktikums-Aufgaben (Abnahme während Praktikumszeit)
\end{enumerate}

\paragraph{SP} schriftliche Prüfung, 90min\\
keine eigenen Unterlagen zugelassen. Nur zuvor ausgegeben Referenzen.

\chapter[Datenbank als System und Modell]{Betriebliche Informations- und Kommunikationssysteme - Unternehmensmodell - Datenbank}

\section{Daten als Unternehmensressource}
\subsection{Daten und Informationen}
Redundante Daten bergen Gefahr von Inkonsistenz $\Rightarrow$ Ziel: Schaffen von Datenbank mit folgenden Eigenschaften:
\begin{itemize}
\item ohne Inkonsistenzen (redundanzarm)
\item Zugriffsschutz
\item Mehrfachzugriff
\item Backup-Möglichkeiten (mit Widerspruchsfreier Wiederherstellung)
\end{itemize}

\folie{1}{1}
\begin{tabular}{r | c c}
& Daten & Informationen\\
\hline
Zweck & zweckneutral & zweckgebunden\\
Verarbeitung & maschinell & Interpretation durch Menschen\\
Speicherform & vergegenständlicht & an Menschen gebunden\\
\end{tabular}
\paragraph{Betriebliche Produktionsfaktoren}
\begin{itemize}
\item klassische Faktoren
\begin{itemize}
\item Betriebsmittel
\item Werkstoffe
\item Arbeitskraft
\end{itemize}
\item Daten + Informationen
\end{itemize}

\folie{1}{2}
Große Datenbestände $\Rightarrow$ Maßnahmen zur Datenorganisation\bigskip\\
Eine mögliche Organisationsform (logisches Konzept): Ablage in Relationen (=Tabelle)\bigskip\\
Eine Zeile in dieser Tabelle nennt man \emph{Datensatz} (Tupel, Record, …).\\
Eine Spalte nennt man \emph{Datenfeld}.

\subsection{Klassifikation von Daten}
\paragraph{Mögliche Kriterien} für Datenfeld
\begin{itemize}
\item Zeichenart
\begin{itemize}
\item ganze Zahl $\Rightarrow$ für Aufzählungen
\item reelle zahl $\Rightarrow$ numerische Berechnungen
\item Währung $\Rightarrow$ finanztechnische Berechnungen
\item Datum $\Rightarrow$ kalendarische Berechnungen/Werte
\item Text $\Rightarrow$ Beschreibung
\item Bitmuster $\Rightarrow$ Video, Bilder, …
\end{itemize}
\item Erscheinungsform
\begin{itemize}
\item sprachlich
\item bildlich
\item schriftlich
\end{itemize}
\item Stellung im Verarbeitungsprozess (E - V - A)
\begin{itemize}
\item Eingabe
\item Verarbeitung
\item Ausgabe
\end{itemize}
\item Verarbeitbarkeit mittels IT\\
(Umwandlung in digitale Daten: analog $\rightarrow$ diskret $\rightarrow$ digital)
\item Verwendungszweck\\
\begin{tabular}{
p{\dimexpr0.2\columnwidth-2\tabcolsep-1.5\arrayrulewidth} | >{\raggedright}
p{\dimexpr0.4\columnwidth-2\tabcolsep-1.5\arrayrulewidth} | >{\raggedright}
p{\dimexpr0.3\columnwidth-2\tabcolsep-1.5\arrayrulewidth}}
& Charakterisierung & Beispiel\tabularnewline
\hline
Stammdaten & selten zu verändern (über längeren Zeitraum in Struktur und Inhalt konstant) & Personalstammdaten (Name, Adresse)\tabularnewline
Änderungsdaten & Aktualisierung der Stammdaten & Änderung der Adresse\tabularnewline
Bestandsdaten & Periodische Änderung des wertes (Inhalt) von Feldern, Datenstruktur besteht über längeren Zeitraum konstant & Lagerbestände, Kassenbestände\tabularnewline
Bewegungsdaten & Daten zur Aktualisierung des Wertes von Bestandsdaten & Lagerzugänge und -abgänge\tabularnewline
Archivdaten & vergangenheitsbezogene Daten die über langeren Zeitraum aufbewahrt werden & Rechnungen, Buchungen der vergangenen 5 Jahre\tabularnewline
Transferdaten & Daten, die von einem anderen Programm erzeugt wurden und an ein anderes transferiert werden & Verkauf von Kundenadresson\tabularnewline
Vormerkdaten & Daten, die solange existieren, bis ein genau definiertes Ereignis eintritt & Reservierung einer Materialmenge im Lager
\end{tabular}
\end{itemize}

\subsection{Datenverschlüsselung}
Gemeint ist nicht die Codierung und Decodierung von Daten, sondern das Zuweisen von Schlüsseln zu Datensätzen.
\folie{1}{3}
\paragraph{Identifizierender Schlüssel} \parskp
kennzeichnet Objekteindeutig\\
Bsp.:
\begin{itemize}
\item Personal-Nr.
\item Material-Nr.
\end{itemize}
\paragraph{Klassifiziernder Schlüssel} \parskp
ordnet Objekt einer Klasse zu\\
Bsp.:
\begin{itemize}
\item Länderkennung: D, C, CH, …
\item Geschlecht: M, W
\end{itemize}
\paragraph{Hierarchischer Verbundschlüssel} \parskp
identifizierender Teil hängt vom klassifizierenden Teil ab\\
Bsp.:
\begin{itemize}
\item Autokennzeichen: $\underbrace{\text{DD}}_{\text{klass.}} \underbrace{\text{XY 715}}_{\text{ident.}}$
\end{itemize}
\paragraph{Parallelschlüssel} \parskp
zwei unabhängige Schlüsselteile\\
Bsp.:
\begin{itemize}
\item Flugnummer $\underbrace{\text{LH 283}}_{\text{Flugnr.}} \underbrace{\text{AB3}}_{\text{Flugzeug}}$
\end{itemize}
\paragraph{spezielle Schlüssel in Datenbanksystemen}
\begin{itemize}
\item \emph{Primärschlüssel} (primary key PK): Datenfeld oder die Kombination aus Datenfeldern, die den Datensatz in der Tabelle eindeutig identifizieren.\\
Bsp. Vereinsdatenbank: \\
Primärschlüssel als einzelnes Datenfeld (Mitgliedertabelle): Migtlieds-ID\\ 
Primärschlüssel als eine Kombination von Datendfeldern (Betragstabelle): ID mit Jahr (für Vereinsbeitrag abhängig von Jahr)
\item \emph{Fremdschlüssel} (foreign key FK): Datenfeld, oder Kombination aus Datenfeldern, der (die) auf den PK einer anderen Tabelle zeigt.\\
Bsp.: Mitglieds-ID in Tabelle mit Datenfelder-Primärschlüssel kommt aus der ersten Tabelle
\item \emph{Referentielle Integrität}: Jeder Wert eines FK muss gleich dem Wert des PK sein, auf den der FK zeigt.\\
Bsp.: Neuer Eintrag in Beitragstabelle kann nur neue Einträge bekommen, die Mitglieder aus Mitgliedertabelle enthält. Anders herum kann aus der Mitgliedertabelle kein Mitglied gelöscht werden, das noch in der Beitragstabelle genutzt wird.
\end{itemize}
\folie{1}{4}

\subsection{Speicher- und Zugriffsformen}
\begin{itemize}
\item \emph{sequentielle Speicherung} (fortlaufend)\\
Bsp.: Bandlaufwerk\\
\begin{tabular}{| c | c | c | c}
101 & 102 & 103 & ...\\
\hline
\end{tabular}
\item \emph{verkettete Speicherung}\\
Bsp.: verkette Listen (vgl. Programmierung I)
\item \emph{indexverkettete Speicherung}\\
Trennung: Datenspeicherung und „Weg“ zu den Daten
\begin{itemize}
\item Indexdatei (sortiert nach entsprechendem Index)
\begin{itemize}
\item Primärindex zeigt auf physische Adresse
\item Sekundärindex zeigt auf Primärindex
\end{itemize}
\item Hauptdatei
\end{itemize}
\folie{1}{5}
\end{itemize}
Unterschied Primärschlüssel-Primärindex:
\begin{itemize}
\item Primärschlüssel dient dem Identifizieren
\item Primärindex zum schnellen Suchen
\end{itemize}

\section[Datenmodelle als Abbild]{Datenmodelle als informationelles Abbild der Unternehmensrealität}
\folie{1}{6}
Informationssystem
\begin{itemize}
\item \emph{Funktionsmodell} (was soll das System leisten: Produktion, Lager, Beschaffung, …) $\Rightarrow$ Kernfrage: „Was will ich machen“\\
Strukturen, Abläufe\\
Technik: Programm-Ablauf-Plan (PAP), Ereignisorientierte Prozessketten (EPK), …
\item \emph{Datenmodell}\\
Daten und deren logische Struktur\\
Technik: Entity-Relationship-Modell (ERM)
\end{itemize}
\folie{1}{7}
\folie{1}{8}
\folie{1}{9}
\subparagraph{Bsp.:} \parskp
\emph{Reale Welt:}\\
\begin{tikzpicture}[scale=.4, thick]
\begin{scope}[shift={(-0.6,-0.2)}]
\draw  (-4.1,3.6) ellipse (0.4 and 0.4);
\draw (-4.1,3.2) -- (-4.1,2.1) -- (-3.8,1.3);
\draw (-4.3,1.3) -- (-4.1,2.1);
\draw (-4.6,3) -- (-4.1,2.7) -- (-3.6,3);
\end{scope}
\begin{scope}[shift={(-0.6,-5.2)}]
\draw  (-4.1,3.6) ellipse (0.4 and 0.4);
\draw (-4.1,3.2) -- (-4.1,2.1) -- (-3.8,1.3);
\draw (-4.3,1.3) -- (-4.1,2.1);
\draw (-4.6,3) -- (-4.1,2.7) -- (-3.6,3);
\end{scope}
\begin{scope}[shift={(-0.6,4.3)}]
\draw  (-4.1,3.6) ellipse (0.4 and 0.4);
\draw (-4.1,3.2) -- (-4.1,2.1) -- (-3.8,1.3);
\draw (-4.3,1.3) -- (-4.1,2.1);
\draw (-4.6,3) -- (-4.1,2.7) -- (-3.6,3);
\end{scope}
\node at (-4.5,10) {Mitarbeiter};
\node at (2.5,9.5) {Projekt};
\draw  (1.5,6.5) rectangle (3.5,4.5) node[pos=.5]{$X$};
\draw  (1.5,0.5) rectangle (3.5,-1.5) node[pos=.5]{$Y$};
\draw (-3.5,7.5) -- (1,6);
\draw (-3.5,2) -- (1,-0.5);
\draw [green] (-3.5,7) -- (1,5.5);
\draw [green] (-3.5,2.5) -- (1,5);
\draw [green] (-3.5,-3) -- (1,-1);
\node [green, right] at (0.5,-3.5) {arbeitet an};
\node [right] at (0.5,-4.5) {leitet};
\end{tikzpicture}\\
\emph{ERM (semantisches Modell):}\\
\begin{tikzpicture}[scale=.5]
\draw  (-3,7) rectangle (1,4.5) node[pos=.5]{Mitarbeiter};
\draw  (-3,-4) rectangle (1,-6.5) node[pos=.5]{Projekt};
\draw (-4,1.5) -- (-7,0) -- (-4,-1.5) -- (-1,0) -- cycle;
\node at (-4,0) {arbeitet an};
\draw (3.5,1.5) -- (0.5,0) -- (3.5,-1.5) -- (6.5,0) -- cycle;
\node at (3.5,0) {leitet};
\draw (-2,4.5) node[below left]{m} -- (-2,3.5) -- (-4,3.5) -- (-4,1.5);
\draw (0,4.5) node[below right]{1} -- (0,3.5) -- (3.5,3.5) -- (3.5,1.5);
\draw (-4,-1.5) -- (-4,-3) -- (-2,-3) -- (-2,-4)  node[above left]{n};
\draw (0,-4) node[above right]{0} -- (0,-3) -- (3.5,-3) -- (3.5,-1.5);
\end{tikzpicture}\\
\emph{RM (relationales/logisches Modell):}\\
\begin{tikzpicture}[scale=.5, thick]
\draw  (-5.5,6) rectangle (-3,5) node (v1) {};
\draw  (-5.5,5) rectangle (-3,4) node (v2) {};
\draw  (-5.5,4) rectangle (-3,3);
\draw  (-3,6) rectangle (-0.5,5) node (v3) {};
\draw  (-0.5,4) node (v4) {} rectangle (v1);
\draw  (-0.5,3) rectangle (v2);
\draw  (-0.5,6) rectangle (2,5) node (v5) {};
\draw  (2,4) rectangle (v3);
\draw  (2,3) rectangle (v4);
\draw  (2,6) rectangle (4.5,5);
\draw  (4.5,4) rectangle (v5);
\draw  (4.5,3) rectangle (2,4);
\draw  (-4.5,-0.5) rectangle (-2,-1.5) node (v6) {};
\draw  (-2,-0.5) rectangle (0.5,-1.5);
\draw  (0.5,-0.5) rectangle (3,-1.5);
\draw  (-4.5,-1.5) rectangle (-2,-2.5);
\draw  (0.5,-2.5) node (v7) {} rectangle (v6);
\draw  (3,-2.5) rectangle (0.5,-1.5);
\draw  (-2,-3.5) rectangle (-4.5,-2.5);
\draw  (0.5,-3.5) rectangle (-2,-2.5);
\draw  (3,-3.5) rectangle (v7);
\draw  (-2,-8.5) rectangle (-4.5,-7.5);
\draw  (-2,-7.5) rectangle (0.5,-8.5);
\draw  (0.5,-7.5) rectangle (3,-8.5);
\draw  (-4.5,-8.5) rectangle (-2,-9.5);
\draw  (0.5,-9.5) rectangle (-2,-8.5);
\draw  (3,-9.5) rectangle (0.5,-8.5);
\node [above right] at (-3.5,-7.5) {Tabelle Projekt};
\node [above right] at (-3.5,-0.5) {Tabelle Bearbeitung};
\node [above right] at (-4.5,6) {Tabelle Mitarbeiter};
\draw [-latex] (3,-3) -- (6,-3) -- (6,-8) -- (3,-8);
\draw [-latex] (3,-9) -- (7,-9) -- (7,5.5) -- (4.5,5.5);
\draw [-latex] (3,-1) -- (6,-1) -- (6,3.5) -- (4.5,3.5);
\end{tikzpicture}

\section[Datenbanksysteme als Grundlage]{Datenbanksysteme als technologische Grundlage der Datenverwaltung}
\folie{1}{10}
\begin{tikzpicture}[scale=.4, thick]
\begin{scope}[shift={(3,0)}]
\draw  (-4.1,3.6) ellipse (0.4 and 0.4);
\draw (-4.1,3.2) -- (-4.1,2.1) -- (-3.8,1.3);
\draw (-4.3,1.3) -- (-4.1,2.1);
\draw (-4.6,3) -- (-4.1,2.7) -- (-3.6,3);
\end{scope}
\begin{scope}[shift={(-5,0)}]
\draw  (-4.1,3.6) ellipse (0.4 and 0.4);
\draw (-4.1,3.2) -- (-4.1,2.1) -- (-3.8,1.3);
\draw (-4.3,1.3) -- (-4.1,2.1);
\draw (-4.6,3) -- (-4.1,2.7) -- (-3.6,3);
\end{scope}
\draw  (-12,-1) rectangle (-6,-3) node[pos=.5]{Applikation};
\draw  (-4,-1) rectangle (2,-3) node[pos=.5]{Applikation};
\draw  (-12,-5) rectangle (2,-8) node[pos=.5]{Datenbankbetriebssytem};
\draw  (-12,-10) rectangle (2,-13) node[pos=.5]{Datenbasis};
\draw [-latex] (-9,-1) -- (-9,1);
\draw [-latex] (-1,-1) -- (-1,1);
\draw [latex-latex] (-9,-3) -- (-9,-5);
\draw [latex-latex] (-1,-3) -- (-1,-5);
\draw [latex-latex] (-5,-10) -- (-5,-8);
\draw [decorate, decoration={brace, amplitude=5pt}] (-13,-13) -- (-13,-5) node[align=center, left, pos=.5]{Daten-\\bank-\\system};
\end{tikzpicture}\\
Datenbasis: Tabellen mit Metadaten\\
Datenbankbetriebssystem (DBMS): Software, die mit Datenbasis kommuniziert

\chapter[Datenbanksystem]{Grundlagen und Architektur eines Datenbanksystems (DBS)}

\section[Konventioneller / Datenbankorientierter Ansatz]{Defekte des konventionellen Ansatzes der Datenverwaltung / Zielstellung des datenbankorientierten Ansatzes}
\paragraph{konventionell} \parskp
\begin{tikzpicture}[scale=.4, thick]
\draw [green] (0,-1) rectangle (-1.5,0.5) node[pos=.5]{1};
\draw [brown] (0,-4) rectangle (-1.5,-2.5) node[pos=.5]{1};
\draw [orange] (-1.5,-5.5) rectangle (0,-7) node[pos=.5]{1};
\node [above] at (-0.5,2.5) {Programm};
\node [above] at (9,2.5) {Dateien};
\node at (9,1) {A};
\node at (9,-1) {B};
\node at (9,-3) {C};
\node at (9,-5) {D};
\node at (9,-7) {E};
\node at (9,-9) {F};
\draw [dashed] (2,2) rectangle (7,-10);
\node [below, align=center, darkgray] at (4.5,-10) {Ziel:\\DBMS};
\draw [green] (0.5,0.5) -- (8,1);
\draw [green] (0.5,0) -- (8,-1);
\draw [green] (0.5,-0.5) -- (8,-3);
\draw [green] (0.5,-1) -- (8,-5);
\draw [brown] (0.5,-3.25) -- (8,-1);
\draw [orange] (0.5,-7) -- (8,-9);
\draw [orange] (0.5,-6.5) -- (8,-7);
\draw [orange] (0.5,-6) -- (8,-5);
\draw [orange] (0.5,-5.5) -- (8,-1);
\end{tikzpicture}
\paragraph{konventionelle Datenorganisation}\parskp
\emph{Merkmale}
\begin{itemize}
\item Datenspeicherung je Anwendung
\item Datenspeicherung auf physischem Niveau
\end{itemize}
\emph{Nachteile}
\begin{itemize}
\item mangelnde Passfähigkeit (Zugriffskonflikte usw.)
\item Redundanz
\item Konsistenzprobleme
\item mangelnde Flexibilität
\item Daten-Programm-Abhängigkeit (kurz: Datenabhängigkeit)
\end{itemize}
\folie{2}{1}
\folie{2}{2}
\folie{2}{3}
\paragraph{Zielsetzung des Datenbankeinsatzes}
\folie{2}{4}
\begin{enumerate}
\item Bsp. für gewollte Redundanz: Sekundärindex
\item Datensicherheit:
\begin{itemize}
\item physisch, falls bspw. der Server abbrennt
\item logisch, dass bspw. alle Daten den richtigen Typ haben
\end{itemize}
\end{enumerate}

\section{Architektur von Datenbanksystemen}

\subsection{Grundlegende Begriffe}
Am Beispiel der Objekte der Datenmodellierung mittels ERM\\
\begin{tabular}{>{\raggedright}
p{\dimexpr0.2\columnwidth-2\tabcolsep-1.5\arrayrulewidth} | >{\raggedright}
p{\dimexpr0.4\columnwidth-2\tabcolsep-1.5\arrayrulewidth} | >{\raggedright}
p{\dimexpr0.3\columnwidth-2\tabcolsep-1.5\arrayrulewidth}
}
Begriff & Erklärung & Beispiel\tabularnewline
\hline 
Entity & Objekt der realen Welt & Max Meier, Arbeitsaufgabe Reportgenerator\tabularnewline
Entity-Typ & Objektklasse (-Menge), enthält Elemente mit struktureller Ähnlichkeit & Mitarbeiter, Arbeitsaufgabe, Abteilung \tabularnewline
Merkmale / Attribut / Prädikat & Beschreibungen eines Entity-Typs & Name, Vorname, Gehalt\tabularnewline
Wert & Ausprägung des Merkmals je Entity, aus einem bestimmten Wertevorrat (Domain) & „Meier“, „Max“, 3800,-\tabularnewline
Beziehung, Set & Logischer Zusammenhang zwischen Entity-Typen & Mitarbeiter -- \underline{arbeitet an} -- Arbeitsaufgabe \tabularnewline
Beziehungstyp, Settyp & Art der Beziehung (mögliche Anzahl an Entitäten, die in Beziehung treten) & $n:1$ Mitarbeiter -- \underline{gehört zu} -- Abteilung ABB50\tabularnewline
\end{tabular}

\subsection{3-Ebenen-Architektur}
gemäß ANSI x3/SPARC (1975)
\begin{itemize}
\item Architekturebene
\begin{itemize}
\item externe Ebene
\item konzeptionelle Ebene
\item interne Ebene
\end{itemize}
\item Modell
\begin{itemize}
\item externes Modell
\item konzeptionelles Modell
\item internes Modell
\end{itemize}
\item Schema (konkrete Ausprägung des Modells)
\begin{itemize}
\item externes Schema
\item konzeptionelles Schema
\item internes Schema
\end{itemize}
\end{itemize}

\subsubsection{Konzeptionelle Ebene}
\paragraph{Gegenstand:} logisches Modell des gesamten Systems
\paragraph{Beschreibungselemente:}
\begin{itemize}
\item Entity-Typen
\item Beziehungen
\item Attribute
\item Wertevorrate (bspw. Einschränkung von Alter: nur Zahlen zwischen 1 und 100)
\item Integritätsbedingung (bspw. NOT NULL, vgl. Wertevorrat)
\end{itemize}
\subsubsection{Externe Ebene}
\paragraph{Gegenstand:} Beschreibung \emph{ausgewählter} Elemente der konzeptionellen Ebene aus Sicht des jeweiligen Endbenutzers
\folie{2}{5}
\paragraph{Element:} Sicht (View)
\subsubsection{Interne Ebene}
\paragraph{Gegenstand:} Form/Art der Ablage der Elemente der konzeptionellen Ebene im physischen Speicher
\paragraph{Element:} Index
\folie{2}{7}

\section{Aufgbau und Arbeitsweise von DBMS}
5 Grundfunktionen eines DBMS
\folie{2}{8}
\subsection{Zugriffsvermittlung}
\folie{2}{9}
\subsection{Unterstützung Datenbeschreibung-Entwicklung}
\folie{2}{10}
\subsection{Integritätssicherung}
\folie{2}{11}
Bsp. operationale Integrität:\\
Gehaltserhöhungen sowohl für Organisatoren (O) und Programmierer (P) um \euro{50,-}.\\
Gehaltserhöhung darf nicht doppelt erfolgen $\Rightarrow$ Sperren von Gehalt, solange ein Nutzer das Gehalt ändert (bei Gefahr bezgl. Deadlock, muss das System das Problem erkennen und entsprechend auflösen).
\subsection{Zugriffsschutz}
\folie{2}{12}
\subsection{Dienstprogrammfunktionen}
\folie{2}{13}

\section{Datenorganisation}
\begin{itemize}
\item logische Datenorganisation (DO)
\begin{itemize}
\item externe Ebene
\item konzeptionelle Ebene
\end{itemize}
\item physische DO
\begin{itemize}
\item interne Ebene
\end{itemize}
\end{itemize}
\paragraph{klassische Datermodelle (logisch)}
\begin{itemize}
\item hierarchisch DM (graphisches DM)
\item Netzwerk DM (graphisches DM)
\item relationales DM (behandelt in DBS I+II)
\end{itemize}
\paragraph{weitere DM}
\begin{itemize}
\item objektorientiertes DM (DBS II)
\item objektrelationales DM (DBS II)
\item XML-DM / NoSQL DM … (DBS III)
\end{itemize}
\folie{2}{14}

\begin{tabular}{
>{\raggedright} p{\dimexpr0.3\columnwidth-2\tabcolsep-1.5\arrayrulewidth} |
>{\raggedright} p{\dimexpr0.22\columnwidth-2\tabcolsep-1.5\arrayrulewidth} |
>{\raggedright} p{\dimexpr0.22\columnwidth-2\tabcolsep-1.5\arrayrulewidth} |
>{\raggedright} p{\dimexpr0.22\columnwidth-2\tabcolsep-1.5\arrayrulewidth} 
}
& Hierarchisches DM & Netzwerk DM & relationales DM\tabularnewline
& ABB 51 & ABB 52 & ABB 53 \tabularnewline
\hline
Einstiegspunkt & ein Entity-Typ & mehrere Entity & beliebig\tabularnewline
strukturelle Beschräknung & Hierarchie & keine & keine \tabularnewline
Zeitpunkt des Aufbau der Beziehung & zur Entwicklungszeit & zur Entwicklungszeit & zur Laufzeit \tabularnewline
Performance & + & + & \Large{\textbf{--}}\tabularnewline
Flexibilität bzgl. Änderung & -- & -- & \Large{\textbf{+}}
\end{tabular}
\chapter{Relationales Datenmodell}
\section{Terminologie im Relationenmodell}
\folie{3}{1}

\paragraph{Bsp.:} \parskp
Entitytyp: 
\begin{itemize}
\item Zeugnis
\end{itemize}
Attribute:
\begin{itemize}
\item $A_1$ Fach
\item $A_2$ Note
\end{itemize}
Wertebereiche:
\begin{itemize}
\item $W_1 \; \{\text{Ma, Ph}\}$
\item $W_2 \{\text{1 ,2 ,3 , 4 , 5}\}$
\end{itemize}
$n=2$, d.h. 2-stellige Relation ableitbar (Grad = degree = 2)\\
$PM = W_1 * W_2 = W_1 \times W_2$\\
\begin{tabular}{c | c}
Fach & Note\\
\hline
Ma & 1\\
Ma & 2\\
Ma & 3\\
Ma & 4\\
Ma & 5\\
Pd & 1\\
Pd & 2\\
Pd & 3\\
Pd & 4\\
Pd & 5\\
\end{tabular}\\
Teilmenge 1  = Relation 1:\\
\begin{tabular}{c | c}
Fach & Note \\
\hline
Ma & 1\\
Ph & 2\\
\end{tabular} \tgreen{gültig}\\
Teilmenge 2  = Relation 2:\\
\begin{tabular}{c | c}
Fach & Note \\
\hline
Ma & 1\\
Ph & 1\\
Ph & 4\\
\end{tabular} \tgreen{gültige Relation} (unabhängig von der semantischen Sinnhaftigkeit)
\folie{3}{2}
\paragraph{Weitere Kernaussagen zum relationalen Modell:}
\begin{itemize}
\item Darstellung der Relation als Tabelle
\item Identifikation der Relation über Namen
\item Anzahl an Attributen (Spalten) ist fest (degree)
\item Anzahl der Tupel (Zeilen) ist variabel (Mächtigkeit)
\item Wertebereiche der Attribute = Domain
\item Im Kreuzungspunkt von Attribut und Tupel stehen \emph{atomare} Werte
\end{itemize}
\section{Definition und Manipulation im relationalen Datenmodell}
\subsection{Datendefinition}
$\Rightarrow$ Definition von Relationen
\folie{3}{3}
\folie{3}{4}
\subsection{Datenmanipulation / Relationenalgebra}
Relationenalgebra nach: Codd\\
Grundidee:\\
Operationen auf Relationen\\
$\Rightarrow$ Ergebnis ist wieder eine \emph{Relation}\\
D.h. mengenweise Arbeit \emph{nicht} satzweise.
\subsubsection{Mengenoperationen} $\cup\; \cap\; \setminus\; \times$\\
ABB57
\folie{3_Beispiele}{1, scale=0.8}
\paragraph{Vereinigung} $\cup$\\
ABB58 orange\\
UNION
\folie{3_Beispiele}{2, scale=0.8}
\paragraph{Durchschnitt} $\cap$\\
ABB58 grün\\
INTERSECTION
\folie{3_Beispiele}{3, scale=0.8}
\paragraph{Differenz} $\setminus$\\
$R_1\setminus R_2$
ABB 58 lila\\
Bedingung für $\cup, \cap, \setminus$ (\emph{Vereinigungsverträglichkeit}):
\begin{itemize}
\item Anzahl an Attributen ist gleich
\item unzugeordnete Attribute besitzen gleiche Domain (Domainverträglichkeit)
\end{itemize}
$R_1\cup R_2 = R_2 \cup R_1$\\
$R_1 \cap R_2 = R_2 \cap R_1$\\
$R_1 \setminus R_2 \not = R_2 \setminus R_1$\\
DIFFERENCE
\folie{3_Beispiele}{4, scale=0.8}
\paragraph{Kartesissches Produkt} $\times$\\
$R_1\times R_2$\\
Ergebnisrelation enthält: 
\begin{itemize}
\item alle Attribute aus $R_1$ und $R_2$.
\item alle Kombinationen an Tupeln aus $R_1$ und $R_2$.
\end{itemize}
ABB 59
\folie{3_Beispiele}{7, scale=0.8}
\subsubsection{Relationale Operationen}
\paragraph{Projektion} Spaltenauswahl\\
PROJ\\
ABB 60 grün
\folie{3_Beispiele}{5, scale=0.8}
\paragraph{Selektion} Tupelauswahl (laut Bedingung)\\
REST\\
ABB 60 orange
\folie{3_Beispiele}{6, scale=0.8}
\paragraph{Verbund} Verbindung zwischen zwei Relationen bezüglich der Gleichheit der Attributwerte in einer Verbindungsspalte\\
JOIN\\
intern:
\begin{enumerate}
\item Kartesisches Produkt der Relation
\item auf Ergebnisrelation Selektion nach Gleichheit der Werte in der/den Verbindungsspalten
\end{enumerate}
Merkmale des JOIN:
\begin{itemize}
\item Attribute über die den JOIN ausgeführt wird, müssen
\begin{itemize}
\item \emph{keine} Schlüsselspalten sein
\item gleiche Domain besitzen
\item \emph{nicht} die gleichen Namen besitzen
\end{itemize}
Jede Relation ist mit jeder Relation via JOIN verbindbar (auch mit sich selbst).
\end{itemize}
\folie{3_Beispiele}{8, scale=0.8}

\section{Normalformenlehre}
Ziele der Normalisierung:
\begin{itemize}
\item Vermeidung unerwünschter Abhängigkeiten beim Ändern, Löschen und Einfügen
\item Reduzierung der Umbildung von Relationen bei Einführung neuer Attribute
\item Erhöhung der Transparenz und Aussagekraft für den Nutzer (Trennung der unterschiedlichen Konzepte der realen Welt)
\item Gewährung der Korrektheit der Datenbakn (zu jedem Zeitpunkt)
\end{itemize}
Vorteile der Normalisierung:
\begin{itemize}
\item Sicherung von relativ einfachen, überschaubaren und einfach handhabbaren Relationen
\item Beseitigung von Update-/Insert- und Delete-Anomalien
\item Einfachere Überprüfung von Konsistenzbedingungen
\end{itemize}
Nachteile:
\begin{itemize}
\item größere Redundanz (Schlüsselredundanz)
\item höherer Aufwand bei komplexen Auswertungen
\end{itemize}
\paragraph{Codd} (1970)\\
Normalform (NF):
$\underbrace{\text{1. NF} \Rightarrow \text{2. NF} \Rightarrow \text{3. NF}}_{\text{praktisch relevant}}\Rightarrow\text{4. NF}\Rightarrow\text{5. NF}$
\subsection{1. Normalform}
\folie{3}{5}
\begin{itemize}[label=$\Rightarrow$]
\item Relation
\begin{itemize}
\item atomare Werte
\item PS erweitern
\end{itemize}
\end{itemize}
\subsection{2. Normalform}
\folie{3}{6}
Abhängigkeiten:\\
\begin{tabular}{r | l | l}
PS & Nichtschlüssel-Attribute & 2. NF\\
\hline
\underline{Mitnr}, \underline{Projnr} & Anteil & MiPro\\
\underline{Mitnr} & Name, Beruf, Gehalt, Abtnr, Abtbez & Mitarbeiter\\
\underline{Projnr} & Projbez & Projekt
\end{tabular}
\begin{itemize}[label=$\Rightarrow$]
\item Zerlegung
\begin{itemize}
\item volle funktionale Abhängigkeit
\end{itemize}
\end{itemize}
\subsection{3. Normalform}
\folie{3}{7}
für Mitarbeiter (M): (x$\to$y: von x kann man auf y schließen)\\
M.Mitnr $\to$ M.Abtnr\\
M.Abtnr $\not \to$ M.Mitnr\\
M.Abtnr $\to$ M.Abtbez\\
Also:\\
M.Mitnr $\to$ M.Abtnr $\to$ M.Abtbez\\
aber:\\
M.Abtnr $\not \to$ M.Mitnr
\begin{itemize}[label=$\Rightarrow$]
\item weitere Zerlegung
\end{itemize}
\underline{Abtnr} $\to$ weitere Tabelle Abteilung mit PS=\underline{Abtnr}.
\folie{3}{8}
\folie{3_Beispiele}{9, scale=0.8}
\folie{3_Beispiele}{10, scale=0.8}

\section{Vergleich relationaler DBMS}
\folie{3}{9}
\begin{align*}
\text{NULL} &= \text{missing value (kein Wert)}\\
&\not = \text{' '}\\
&\not = \emptyset
\end{align*}
\folie{3}{10}
\folie{3}{11}

\chapter{Datenbanksprachen für relationale DBMS}
\section{Benutzergruppen und Datenbanksprachen}
Benutzergruppen:\\
ABB 77
\paragraph{Einordnung der Datenbanksprache SQL}
Einteilung der Programmiersprachen:
\begin{itemize}
\item klassisch nach Gen. 1-4
\item weitere Einteilung
\end{itemize}
\Folie{4}{1}
\Folie{4}{2}
\subparagraph{3. Generation of Language (GL)}
(prozedural)
\begin{lstlisting}[language=C]
opne (buecher);
while (not EOF(buecker)){
	read (buch);
	if (buch.leihfrist > 21)
		print (buch.titel);
}
close (buecher);
\end{lstlisting}
$\Rightarrow$ WIE
\subparagraph{4. GL}
(descriptiv, \emph{nicht} prozedural)
\begin{lstlisting}[language=SQL]
SELECT titel
FROM buecher
WHERE leihfrist > 21
\end{lstlisting}
$\Rightarrow$ WAS
\Folie{4}{3}

\section{SQL als Standardsprache für relationale DBMS}
\subsection{Überblick}
SQL - Structured Query Language
\begin{itemize}
\item Structured -- „oft etwas übertrieben“
\item Query -- „bescheiden“
\item Language -- „unanfechtbar“
\end{itemize}
\Folie{4}{4}
\Folie{4}{5}
Klassen an SQL-Befehlen:
\begin{itemize}
\item DDL -- Data Definition Language
\item DCL -- Data Control Language
\item DML -- Data Manipulation Language
\end{itemize}
Dialekte:\\
z.B.:
\begin{itemize}
\item pl SQL $\Rightarrow$ Oracle (Postgresql)
\item t SQL $\Rightarrow$ MS SQL-Server, Sybase (SAP)
\end{itemize}
\subsubsection{SQL-Datentypen (Auswahl)}
\begin{itemize}
\item exakte Numerische Werte
\begin{itemize}
\item INT ganze Zahl mit VZ
\item SMALLINT ganze Zahl mit VZ (kleinerer Wertebereich als INT)
\item DECIMAL (m,n) Dezimalzahl mit $m$ Stellen, davon $n$ \emph{exakte} Nachkommastellen
\end{itemize}
\item numerische Näherungswerte (Gleitkommazahl)
\begin{itemize}
\item FLOAT (n) Gesamtstellenanzahl $n$
\item DOUBLE PRECISION i.A. größerer Wertebereich als FLOAT
\end{itemize}
\item Datum/Uhrzeit (abhängig vom System)
\begin{itemize}
\item DATE
\item TIME
\item DATETIME
\end{itemize}
\item Zeichenketten (Zeichenkette der Länge $n$)
\begin{itemize}
\item CHAR (n) (Speichert gesamte Zeichenketten)
\item VARCHAR (n) (Speichert Zeichenkette ohne Leerzeichen)
\end{itemize}
\item weitere spezielle Typen
\begin{itemize}
\item BIT (n) Bitkette der Länge $n$
\item BLOB (n) Binary-Array
\item TEXT Zeichenkette
\item CLOB (n) Zeichenkette
\item IMAGE Bilder
\item BOOLEAN Boolsche Werte
\item MONEY Währung
\item XML
\item …
\end{itemize}
\end{itemize}
\subsubsection{Symbole der Syntaxbeschreibung:} (EBNF)\\
\begin{tabular}{c l}
$|$ & Alternative (XOR)\\
$[\;]$ & optionales Element (ein- oder keinmal)\\
$\{\;\}$ & Gruppierungen (ein- oder mehrmals)\\
$...$ & Wiederholung\\
$<\;>$ & Sprachbeschreibende Variablen\\
$::=$ & Definitionssymbol
\end{tabular}
\subsection{Anweisungen zur Definiton (DDL-Befehle)}
\subsubsection{Tabellendefinition}
\paragraph{Anlegen einer Tabelle}
\Folie{4}{6}
\begin{lstlisting}[language=SQL]
CREATE TABLE Kunde(
	KuNr	 			INT PRIMARY KEY,
	Name 				CHAR(10) NOT NULL, 
	Vorname 		CHAR(10),
	Ort					CHAR(20),
	Gebdatum 		DATETIME NULL,
	Geschlecht	CHAR(1) NULL,
	TelNr				INT,
	CHECK( 999 < TelNr < 10000)
)
\end{lstlisting}
\begin{itemize}
\item PRIMARY KEY: Primärschlüssel
\item NULL: missing value (empty) $\not =0\; \not = '\,'$ (typübergreifend)
\item NOT NULL: Werteingabe zwingend\\
(wenn weder NULL noch NOT NULL da steht: wird vom System bestimmt $\to$ wird entweder NULL oder NOT NULL gesetzt. Empfehlung: für jeden Eintrag selber festlegen!)
\item UNIQUE: eindeutiger Wert
\end{itemize}
\begin{lstlisting}[language=SQL]
CREATE TABLE Artikel (
	Artnr SMALLINT PRIMARY KEY, 
	Bezeichnung CHAR(15) NOT NULL,
	Beschreibung CHAR(30) NULL,
	EPreis DECIMAL(7,2) NOT NULL
)
\end{lstlisting}
\begin{lstlisting}[language=SQL]
CREATE TABLE Kauf (
	Kunr INT,
	Artnr SMALLINT,
	Menge INT NOT NULL,
	VPreis decimal(8,2) NOT NULL, 
	PRIMARY KEY(Kunr, Artnr), 
	FOREIGN KEY(Kunr) REFERENCES Kunde(Kunr),
	FOREIGN KEY(Artnr) REFERENCES Artikel(Artnr)
)
\end{lstlisting}
Bei zusammengesetzten Primärschlüsseln muss dieser am Ende von \emph{creat table} definiert werden. Bei einem einfachen kann dies \emph{inline} passieren oder auch wie beim zusammengesetzten am Schluss: 
\begin{lstlisting}[language=SQL]
CREATE TABLE Artikel (
	Artnr SMALLINT, 
	Bezeichnung CHAR(15) NOT NULL,
	Beschreibung CHAR(30) NULL,
	EPreis DECIMAL(7,2) NOT NULL,
	PRIMARY KEY (Artnr)
)
\end{lstlisting}
\paragraph{Ändern der Tabellendefinition}
\Folie{4}{7}
\subparagraph{Bsp.:} Spalte Email an Tabelle Kunde anfügen.
\begin{lstlisting}[language=SQL]
ALTER TABLE Kunde ADD email CHAR(20) NULL
\end{lstlisting}
Fall: neue Spalte soll \emph{NOT NULL} sein. Entweder \emph{default}-Wert übergeben oder erst als \emph{NULL} einführen, Inhalte befüllen und dann \emph{NOT NULL setzen}.
\paragraph{Löschen einer Tabelle} $ $
\begin{lstlisting}[language=SQL]
DROP TABLE tab_name
\end{lstlisting}
Beispiel:
\begin{lstlisting}[language=SQL]
DROP TABLE Kauf
\end{lstlisting}
Befehl wird ohne Nachfrage ausgeführt (wenn Tabelle nicht als Referenz verwendet wird)!
\subsubsection{Arbeiten mit Index}
(Primär-)Index dient dem schnellen Suchen, Primärschlüssel dient nur dem Identifizieren.
\paragraph{Anlegen des Index} $ $
\begin{lstlisting}[language=SQL]
CREATE INDEX index_name ON tab_name(index)
\end{lstlisting}
Bsp.: Zusammengesetzter Index (Kunde nach Ort und dann nach Name indexiert)
\begin{lstlisting}[language=SQL]
CREATE INDEX iOrtName ON Kunde(Ort,Name)
\end{lstlisting}
\paragraph{Löschen eines (Sekundär-)Index} $ $
\begin{lstlisting}[language=SQL]
DROP INDEX tab_name.index_name
\end{lstlisting}
\begin{lstlisting}[language=SQL]
DROP INDEX Kunde.iOrtName
\end{lstlisting}
\subsubsection{View-Definition}
\Folie{4}{8}
Eine View kann auch Daten aus mehreren Tabellen nehmen.
\paragraph{Anlegen einer View} $ $
\begin{lstlisting}[language=SQL]
CREATE VIEW view_name [ ( <Spaltenliste> ) ] 
AS <select_anweisung>
\end{lstlisting}
Bsp.:
\begin{lstlisting}[language=SQL]
CREATE VIEW Beruf_Inf
AS (
	SELECT Kunr, Name, Vorname, Ort
	FROM Kunde
	WHERE Beruf = 'Informatiker'
)
\end{lstlisting}
\paragraph{Löschen einer View} $ $
\begin{lstlisting}[language=SQL]
DROP VIEW view_name
\end{lstlisting}
Bsp.:
\begin{lstlisting}[language=SQL]
DROP VIEW Beruf_Inf
\end{lstlisting}
\paragraph{Zugriff auf eine View} $ $
\begin{lstlisting}[language=SQL]
SELECT Kunr, Name
FROM Beruf_Inf -- (View Name)
\end{lstlisting}

\subsection{Anweisungen zur Abfrage (DML-Befehle)}
\subsubsection{Standardabfrage}
\Folie{4}{9}
\begin{lstlisting}[language=SQL]
SELECT	Bilbereich					<Attributliste>		Was?
FROM		Definitionsbereich	<Relation>				Wovon?
WHERE		Auswahlkriterien		<Bedingungen>			Bedingung?
\end{lstlisting}
\subsubsection{Einfache Abfrage auf eine Relation}
\begin{lstlisting}[language=SQL]
SELECT < attributliste >
FROM < tab_name > | < view_name >
[ WHERE < auswahlbedingung > ]
\end{lstlisting}
einfachste Abfrage:
\begin{lstlisting}[language=SQL]
SELECT *	-- * ... alle Attribute (Spalten)
FROM Kunde
\end{lstlisting}
Beim Programmieren am besten nicht * verwenden. Nur für's Abfragen. * ist Fehleranfällig bei Veränderungen!
\begin{lstlisting}[language=SQL]
SELECT Name, Vorname
FROM im15s12345.dbo.Kunde 		-- (Datenbank.Eigentümer.Tabellenname)
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT Name, Vorname
FROM Kunde
WHERE Ort='Dresden'
\end{lstlisting}

\paragraph{Abfrage mit Vergleichs- und logischen Operatoren} $ $
\begin{lstlisting}[language=SQL]
SELECT * FROM Kunde 
	WHERE Geschl = 'M'

SELECT * FROM Kunde 
	WHERE (Ort='Pirna' OR Ort='Dresden') AND Beruf = 'Projektant'

SELECT * FROM Artikel
	WHERE NOT Artnr = '1234'		-- Alternativ: Artnr != '1234'
\end{lstlisting}

\paragraph{Abfrage mit Patternsuche}$ $
\begin{lstlisting}[language=SQL]
... WHERE <spaltenname> LIKE 'muster'
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT * FROM Kunde
WHERE Name LIKE '%GmbH'

SELECT * FROM Kunde
WHERE Name LIKE 'M_$\,$_er' -- sucht bspw. Maier, Meyer oder Mayer
\end{lstlisting}

\subparagraph{Funktion}
\begin{lstlisting}[language=SQL]
SUBSTR ( <spaltenname>, <startpos>, <länge> )
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT * FROM Kunde 
WHERE SUBSTR(Name, 2,2)='ei'	-- ACHTUNG: substring fängt bei 1 an zu zählen: 1. Zeichen ist nicht an der Stelle 0, sondern tatsächlich 1
-- das gleiche wie:
WHERE Name LIKE '_ei%'
\end{lstlisting}
\subparagraph{Bereich}$ $
\begin{lstlisting}[language=SQL]
SELECT * FROM Kunde 
WHERE Name LIKE '[E-N]%'	-- alle Namen die mit Buchstaben zwischen E und N beginnen
WHERE Name LIKE '[^E-N]%'	-- alle, die nicht mit Buchstaben zwischen E und N beginnen
\end{lstlisting}

\paragraph{Attributzuweisung in Abfrage}$ $
\begin{lstlisting}[language=SQL]
AS <spaltenname>
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT Kunr, Name, AS Kundenname
FROM Kunde 

SELECT Kunr, Vorname | ', ' | Vorname AS Kundenname
FROM Kunde
\end{lstlisting}
zweiteres würde liefern:\\
\begin{tabular}{l | l}
Kunr & Kundenname\\
\hline
123 & Maier, Uwe\\
234 & Adler, Sabine\\
…
\end{tabular}
\begin{lstlisting}[language=SQL]
SELECT Kunr, Artnr, Menge*vPreis AS Umsatz
FROM Kauf
\end{lstlisting}
liefert:\\
\begin{tabular}{l l | l}
Kunr & Artnr & Umsatz\\
\hline
123 & 1234 & 3600\\
234 & 5555 & 500\\
…
\end{tabular}
\paragraph{Datumsfunktionen}$ $
\begin{enumerate}
\item $ $ \begin{lstlisting}[language=SQL]
DAY(), MONTH(), YEAR(), HOUR(), ...
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT YEAR(GebDat)
FROM Kunde
\end{lstlisting}
\item $ $\begin{lstlisting}[language=SQL]
DATEDIFF ( <datepart>, <begin>, <end> ) -- <datepart>: dd, mm, yy
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT DATEDIFF (dd, GETDATE(), '24/12/2016') -- Achtung Formatierung des Datums ist von DBMS abhängig (ob / oder . und Reihenfolge)
\end{lstlisting}
\item $ $\begin{lstlisting}[language=SQL]
DATEADD ( <datepart>, <number>, <date> )
\end{lstlisting}
\begin{lstlisting}[language=SQL]
DATEADD ( dd, 50, GETDATE() )
\end{lstlisting}
\end{enumerate}

\subsubsection{Sortierung / Gruppenbildung}
\Folie{4}{10}
\paragraph{Sortierung} $ $
\begin{lstlisting}[language=SQL]
SELECT * FROM Kunde
ORDER BY Name, Vorname

SELECT * FROM Kunde
ORDER BY GebDat DESC	-- jüngste zuerst
\end{lstlisting}
\paragraph{Gruppierung} $ $
\begin{lstlisting}[language=SQL]
SELECT Ort, SUM( Kredit ) AS Kreditsumme
-- Achtung! Auswahl kann nicht auf bspw. Name erweitert werden, weil dann die Tabelle für einen Ort mehrere Namen hätte
-- Ähnlich: Nicht mit bspw. Kredit erweitertbar. ABER: Möglich ist SUM(Kredit), was dann alle Werte für den Ort aufsummieren würde
FROM Kunde
GROUP BY Ort	-- Jeder Ort taucht nur einmal auf
\end{lstlisting}

\subsubsection{Built-in-Funktionen}
(Aggregatfunktionen, Statistikfunktionen)
\begin{lstlisting}[language=SQL]
SUM ()
AVG ()
MAX ()
MIN ()
COUNT ()
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT SUM( Kredit ) 
FROM Kunde		-- Summe aller Kredite von allen Kunden (eine Tabelle mit nur einem Eintrag: der Summe)

-- weiteres Bsp. siehe Gruppierung

SELECT Artnr, SUM( Menge*vPreis ) AS UmSum
FROM Kauf
GROUP BY Artnr
\end{lstlisting}
Count:
\begin{lstlisting}[language=SQL]
COUNT (<spaltenname>)	-- zählt belegte Werte einer Spalte. Einträge mit NULL werden nicht gezählt.
COUNT (*)		-- zählt auch NULL-Werte, also einfach alle Zeilen
DISTINCT		-- zählt keinen Wert mehrfach
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT COUNT(*)		-- Anzahl der Kunden
FROM Kunde

SELECT COUNT(DISTINCT Ort)	-- Anzahl der Orte ohne Dopplungen
FROM Kunde

SELECT DISTINCT Ort	-- Zählt Orte ohne Dopplungen auf
FROM Kunde
\end{lstlisting}

\subsubsection{Abfrage mit Bereichsgrenzen und Wertaufzählungen}
\paragraph{Bereich} $ $
\begin{lstlisting}[language=SQL]
BETWEEN x AND y
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT * FROM Kauf
WHERE vPreis BETWEEN 400 AND 1000
\end{lstlisting}
\paragraph{Aufzählung} $ $
\begin{lstlisting}[language=SQL]
IN (<liste>)
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT * FROM Kunde
WHERE Beruf IN('Maler', 'Schlosser', 'Tischler')
\end{lstlisting}

\subsubsection{Einfache Abfrageschachtelung}
(hinter dem WHERE steht eine Unterabfrage)
\begin{lstlisting}[language=SQL]
SELECT * FROM <tab_name>
WHERE <spaltenname> [ = | IN ] (	-- = benutzen, falls Unterabfrage einzelnen Wert zurück gibt, IN-Operator benutzen, falls eine Wertliste durch Unterabfrage erzeugt wird
	SELECT <sp_name>
	FROM <tab_name>
	[WHERE]
)
\end{lstlisting}
Abfrage von Name, Ort, GebDat des ältesten Dresdner Kunden:
\begin{lstlisting}[language=SQL]
SELECT Name, Ort, GebDat FROM Kunde
WHERE GebDat = (
	SELECT MIN(GebDat)
	FROM Kunde
	WHERE Ort='Dresden'	-- genau ein Wert
)	-- Achtung: hätten zwei älteste am gleichen Tag Geburtstag und einer würde nicht aus Dresden kommen, dann würde diese mit angegeben. Also:
AND Ort='Dresden'
\end{lstlisting}
Alle Kunden, die etwas gekauft haben (bzw. in Kauf eingetragen sind) aus Dresden:
\begin{lstlisting}[language=SQL]
SELECT * FROM Kauf
WHERE Kunr IN (
	SELECT KuNr FROM Kunde
	WHERE Ort='Dresden'
)
\end{lstlisting}

\subsubsection{Abfrage über mehrere Relationen}
$\Rightarrow$ JOIN
\Folie{4}{11}
\subparagraph{Bsp.:} Anzeige der Artikeldaten und deren Käufe
Mehrere Varianten:
\begin{enumerate}
\item WHERE:
\begin{lstlisting}[language=SQL]
SELECT  Artikel.Artnr, Bezeichnung, Menge, VPreis
FROM Artikel, Kauf
WHERE Artikel.Artnr = Kauf.Artnr
\end{lstlisting}
\item mit Alias:
\begin{lstlisting}[language=SQL]
SELECT a.Artnr, Bezeichnung, Menge, VPreis
FROM Artikel a, Kauf k
WHERE a.Artnr = k.Artnr
\end{lstlisting}
\item JOIN:
\begin{lstlisting}[language=SQL]
SELECT a.Artnr, Bezeichnung, Menge, VPreis
FROM Artikel a
JOIN Kauf k ON a.Artnr = k.Artnr
\end{lstlisting}
\end{enumerate} 
Zusätzlich: Name des Kunden anzeigen und nur Kunden aus Dresden:
\begin{enumerate}
\item WHERE:
\begin{lstlisting}[language=SQL]
SELECT A.Artnr, Bezeichnung, Menge, U.Kunr, Name
FROM Artikel A, Kauf K, Kunde U
WHERE A.Artnr = K.Artnr		-- implizite Bedingung(en)
	AND K.Kunr = U.Kunr			-- implizite Bedingung(en)
	AND Ort = 'Dresden'			-- explizite Bedingung(en)
\end{lstlisting}
\item JOIN:
\begin{lstlisting}[language=SQL]
SELECT A.Artnr, Bezeichnung, Menge, U.Kunr, Name
FROM Artikel A
JOIN Kauf K ON A.Artnr = K.Artnr	-- JOIN: implizite Bedingung(en)
JOIN Kunde U ON K.Kunr = U.Kunr		-- JOIN: implizite Bedingung(en)
WHERE Ort='Dresden'								-- WHERE: explizite Bedingung(en)
\end{lstlisting}
$\Rightarrow$ JOIN ist der ersten Variante zu bevorzugen, da die impliziten und expliziten Bedingungen klar und auf den ersten Blicks erkennbar sind.
\end{enumerate}
\subsubsection{Weitere Abfragemöglichkeiten}
\Folie{4}{12}
\begin{itemize}
\item Equi-JOIN
\begin{lstlisting}[language=SQL]
SELECT Kunde.*, Kauf.*
FROM Kunde, Kauf
WHERE Kunde.Kunr = Kauf.Kunr
\end{lstlisting}
\item Natural JOIN
\begin{lstlisting}[language=SQL]
SELECT Kunde.*, Artnr, Menge, VPreis -- Kauf.*-Kunr oder vergleichbares nicht möglich! Es müssen alle Spalten manuell angegeben werden
FROM Kunde, Kauf
WHERE Kunde.Kunr = Kauf.Kunr

-- alternativ in JOIN-Schreibweise:
SELECT Kunde.*, Artnr, Menge, VPreis
FROM Kunde
JOIN Kauf ON Kunde.Kunr = Kauf.Kunr
\end{lstlisting}
\item Kartesisches Produkt
\begin{lstlisting}[language=SQL]
SELECT *
FROM Kunde, Kauf
\end{lstlisting}
\item Theta JOIN
\begin{lstlisting}[language=SQL]
SELECT *
FROM Kunde, Kauf
WHERE Kunde. Kunr != Kauf.Kunr
\end{lstlisting}
Entspricht $\text{(Kartesisches Produkt)}-\text{(Equi-Join)}$
\item Outer JOIN
\begin{itemize}
\item Right
\item Left
\item Full
\end{itemize}
\begin{lstlisting}[language=SQL]
SELECT *
FROM Kunde K
FULL OUTER JOIN Kauf F	-- Schaut in beide Tabellen (Kauf und Kunde) und fügt die hinzu, die keinen Zusammenhang haben
-- bei LEFT OUTER JOIN: Schaut in die "linke" Tabelle (Kunde) und prüft, welche im Zusammenhang mit Kauf nicht auftauchen (sprich: welcher Kunde nichts gekauft hat)
-- bei RIGHT OUTER JOIN: Schaut in die "rechte" Tabelle (Kauf) (sprich: welcher Kauf keinen Kunden hat: nicht möglich)
	ON K.Kunr = F.Kunr
\end{lstlisting}
\end{itemize}
\subsubsection{Abfrageschachtelungen}
Arten von Unterabfragen(UA):
\begin{itemize}
\item einfach/unkorreliert
\begin{itemize}
\item UA wird einmal ausgeführt und in die Hauptabfrage (HA) eingesetzt
\end{itemize}
\item abhängig/korreliert
\begin{itemize}
\item UA wird für jeden Tupel der HA einmal ausgeführt
\item UA (innere Abfrage) bezieht sich auf eine (oder mehrere) Tabellen, die \emph{nur} in der FROM-Klausel der HA aufgeführt sind
\end{itemize}
\end{itemize}
\paragraph{Bsp.:} unkorrelierte UA
\begin{itemize}
\item Alle Käufe in Dresden (Kunden).
\begin{lstlisting}[language=SQL]
SELECT *
FROM Kauf
WHERE Kunr IN (
	SELECT Kunr
	FROM Kunde
	WHERE Ort='Dresden'
)
\end{lstlisting}
\item Anzeige Artnr, Bezeichnung und Einkaufspreis, sowie maximal erzielter VPreis je Artikel.
\begin{lstlisting}[language=SQL]
SELECT UA.Artnr, VPreisMax, Bezeichnung, EPreis
FROM (SELECT Artnr, MAX(VPReis) AS VPreisMax	-- Alias sehr wichtig, damit Spalte in HA wieder verwendet werden kann!
	FROM Kauf
	GROUP BY Artnr
) UA	-- Unterabfrage für Tabelle von max. VPreis
JOIN Artikel ON Artikel.Artnr = UA.Artnr
\end{lstlisting}
Diese Schachtelung kann beliebig weiter fortgesetzt werden.
\item Anzeige aller Kunden, deren Umsatz (= Menge * VPreis) größer als deren Kreditlimit ist.
\begin{lstlisting}[language=SQL]
SELECT K.*
FROM (SELECT Kunr, SUM(Menge*VPreis) AS Umsatzsumme
	FROM Kauf
	GROUP BY Kunr
) UA
JOIN Kunde K ON UA.Kunr = K.Kunr
WHERE Umsatzsumme > Kredit
\end{lstlisting}
\end{itemize}
\paragraph{Bsp.:} korrelierte UA
\begin{itemize}
\item Gleiches Beispiel, wie letztes unkorreliertes.
\begin{lstlisting}[language=SQL]
SELECT * 				-- hier HA
FROM Kunde 
WHERE Kredit < (
	SELECT SUM(Menge*VPreis)		-- ab hier UA
	FROM Kauf
	WHERE Kauf.Kunr = Kunde.Kunr
)
\end{lstlisting}
Ergebnis ist das gleiche wie in der unkorrelierten Abfrage.
\end{itemize}

\paragraph{Bsp.:} korrelierte, unkorrelierte UA\\
Anzeige von Name und Ort der Kunden deren Umsatz (Umsatzsumme) größer als deren Kreditlimit ist.\\
unkorreliert:
\begin{lstlisting}[language=SQL]
SELECT K.Kunr, K.Name, K.Ort
FROM (
	SELECT Kunr,
	SUM (Menge*vPreis) AS U-Summe
	FROM Kauf
	GROUP BY Kunr) UA
JOIN Kunde K
ON K.Kunr = UA.Kunr
WHERE U-Summe > Kredit
\end{lstlisting}
korreliert:
\begin{lstlisting}[language=SQL]
SELECT Kunr, Name, Ort
FROM Kunde
WHERE Kredit < (
	SELECT SUM (Menge * vPreis) AS U.Summe
	FROM Kauf	-- Kunde hier nicht enthalten!
	WHERE Kauf.Kunr = Kunde.Kunr )	-- Kunden-Info aus übergeordneter Abfrage
\end{lstlisting}

\subsubsection{Mengen-Operationen}
\Folie{4}{13}
ABB 150\\
Allgemein in SQL:
\begin{lstlisting}[language=SQL]
SELECT ...
FROM ...
[WHERE ...]
UNION | INTERSECT | EXCEPT
SELECT ...
FROM ...
[WHERE ...]
\end{lstlisting}
\paragraph{Bsp.:}$ $
\begin{lstlisting}[language=SQL]
SELECT VNum, VName
FROM Verkaeufer
WHERE Ort='Dresden'
UNION
SELECT KNum, KName
FROM Kunden
WHERE Ort='Dresden'
\end{lstlisting}

\subsubsection{EXISTS / NOT EXISTS-Operator}
\Folie{4}{14}
\paragraph{Bsp.:} $ $
\begin{lstlisting}[language=SQL]
SELECT Name, Ort
FROM Kunde
WHERE EXISTS (
	SELECT * 
	FROM Kunde
	WHERE Ort LIKE 'Dre%')
\end{lstlisting}
\subsubsection{SOME/ANY, ALL}
\paragraph{Bsp.:}$ $
\begin{lstlisting}[language=SQL]
SELECT *
FROM Kunde
WHERE Kunr = ANY (
	SELECT Kauf.Kunr
	FROM Kauf
	WHERE Kunde.Kunr = Kauf.Kunr) -- Kunde-Info wieder aus übergeordneter Abfrage
\end{lstlisting}
\paragraph{Bsp.:} Ausgabe aller Daten des jüngsten Kunden
\begin{lstlisting}[language=SQL]
SELECT * 
FROM Kunde
WHERE Gebdat >= ALL(
	SELECT Gebdat
	FROM Kunde)
\end{lstlisting}
\subsubsection{HAVING-Klausel (im Unterscheid zu WHERE)}
HAVING „filtert“ auf Gruppen: „HAVING ist das WHERE vom GROUP BY“.
\paragraph{Bsp.:} $ $
\begin{lstlisting}[language=SQL]
SELECT Ort, SUM (Kredit)
FROM Kunde
GROUP BY Ort
HAVING SUM(Kredit) > 2000
\end{lstlisting}
\begin{lstlisting}[language=SQL]
SELECT Ort, SUM (Kredit)
FROM Kunde
WHERE Ort LIKE 'D%'	-- Filter auf Einzeldatensätzen
GROUP BY Ort
HAVING SUM(Kredit) > 2000	-- Filter auf den Gruppen
\end{lstlisting}

\subsection{Anweisung zur Datenmanipulation}
\subsubsection{Einfügen vor Datensätzen}
\begin{lstlisting}[language=SQL]
INSERT INTO <tab_name> [ ( <spalte1>, <spalte2>, ... ) ]
	{[VALUES (wert1, wert2, ...)] | 
	[SELECT <spalte1>, <spalte2>, ... FROM <tab_name1>]}
\end{lstlisting}
INSERT-Varianten:
\begin{itemize}
\item 1 Datensatz:\\
VALUES
\item Datensatzmenge:\\
SELECT
\end{itemize}
\paragraph{Bsp.:} $ $
\begin{lstlisting}[language=SQL]
INSERT INTO Kunde
VALUES (110, 'Strobl', 'Frank', 'Dresden', '1977-2-27', 'm', 'Student', 500)
-- oder auch (nicht in Microsoft SQL aber MySQL)
VALUES (110, 'Strobel', 'Frank',,,,, 500)
-- besser:
VALUES (110, 'Strobel', 'Frank', null, null, null, null, 500)
-- oder:
INSERT INTO Kunde (Kunr, Name, Vorname, Ort)
VALUES (110, 'Strobel', 'Frank', 'Dresden')
\end{lstlisting}
Datensatzmenge einfügen:
\begin{lstlisting}[language=SQL]
INSERT INTO Kunde(Kunr, Name, Vorname, Ort)
	SELECT Kunr, AName, AVorname, AOrt
	FROM Adresse
	WHERE AOrt LIKE 'Dre%'
\end{lstlisting}
\subsubsection{Ändern von Datensätzen}
\begin{lstlisting}[language=SQL]
UPDATE <tab_name> SET <spalte1> <ausdruck1> [, <spalte2> <ausdruck2>, ...]
\end{lstlisting}
\paragraph{Bsp.:} $ $
\begin{lstlisting}[language=SQL]
UPDATE Kunde SET Ort='Pirna'
WHERE Ort='Dresden' -- geht auch ohne WHERE, würde dann bloß in ALLEN Datensätze Ort auf Pirna setzen.

UPDATE Artikel SET EPreis = EPreis*1.1	-- 10 % Preiserhöhung
WHERE ... --korrelierte/unkorrelierte UA
\end{lstlisting}
\subsubsection{Löschen von Datensätzen}
\begin{lstlisting}[language=SQL]
DELETE <tab_name> [WHERE <bedingung> ]
\end{lstlisting}
\paragraph{Bsp.:} $ $
\begin{lstlisting}[language=SQL]
DELETE FROM Kauf
WHERE KuNr IN ( 
	SELECT KuNr
	FROM Kunde
	WHERE Ort LIKE 'Dre%')
	
DELETE FROM Kunde	-- Kann erst ausgeführt werden, wenn oberer Befehl ausgeführt werden. Wegen referenzieller Integrität!
WHERE Ort LIKE 'Dre%'
\end{lstlisting}
\paragraph{Befehlsübersicht} Diese Befehle beziehen sich auf …
\begin{itemize}
\item Metadaten (Objekt) (z.B. Tabellendefinition, View-Definition)
\begin{itemize}
\item CREATE
\item ALTER
\item DROP
\end{itemize}
\item Dateninhalt (der Tabelle/View)
\begin{itemize}
\item INSERT
\item UPDATE
\item DELETE
\end{itemize}
\end{itemize}

\section{Query By Example (QBE)}
graphische Oberfläche\\
Bsp.: Access

\section{DBMS-spezifische Erweiterungen vom Standard-SQL (T-SQL)}
\subsection{Statements zur Ablaufkontrolle}
\Folie{4}{15}
\subsubsection{IF}
\begin{lstlisting}[language=SQL]
IF SELECT AVERAGE(vPreis) FROM Kauf < 40
	UPDATE Kauf SET vPreis=vPreis*1.1	-- für Produkte mit vPreis <40 wird der Preis um 10% erhöht
\end{lstlisting}
\subsubsection{IF EXISTS}
\begin{lstlisting}[language=SQL]
IF EXISTS (SELECT COUNT(*) FROM Kunde WHERE Name='Adler')
	PRINT 'Adler vorhanden'
\end{lstlisting}
\subsubsection{WHILE / WAITFOR}
\begin{lstlisting}[language=SQL]
WHILE 2>1	-- Endlosschleife
	BEGIN
		WAITFOR DELAY '1:00:00'	-- eine Stunde warten
		SELECT GETDATE()
		EXEC sp_who	-- Liste aktiver Nutzer auf Server
	END
\end{lstlisting}
\subsection{Benutzung von Variablen}
\Folie{4}{16}
\begin{tabular}{l l l}
& \textbf{global} & \textbf{lokal} \\
Deklaration: & System & im Programmcode\\
Bezeichnung: & @@name & @myname\\
Wertzuweisung: & System & select-Befehl (Konstante/Wert aus Relation übergeben)\\
Zugriff: & Lesend & Lesend + Schreibend
\end{tabular}
\subsection{Anzeigen von Nachrichten}
\begin{tabular}{l c l}
PRINT & $\Rightarrow$ & ASCII-Zeichen\\
SELECT & $\Rightarrow$ & Dateninhalte ausgeben\\
& $\Rightarrow$ & Zuweisung von Variablen\\
RAISERROR & $\Rightarrow$ & Fehlermeldungen ausgeben
\end{tabular}

\paragraph{Bsp.:}$ $
\begin{lstlisting}[language=SQL]
DECLARE @myName CHAR(10),
	@myKnr INT
SELECT @myKunr = 345	-- Wertzuweisung  braucht SELECT!!!
SELECT @myName = Name	-- Wert aus Relation
	FROM Kunde
	WHERE Kunr = @myKunr
-- diese beiden SELECTS liefern keine Ergebnismenge: sind nur Wertzuweisungen
PRINT 'Kunr= ' + CONVERT(CHAR(10), @myKunr)
PRINT 'Name= ' + @myName	-- Achtung: 'test'+NULL gäbe insgesamt NULL, also keine Ausgabe, Lösung:
PRINT 'Name= ' + ISNULL(@myName, 'kein Name')
\end{lstlisting}
\paragraph{zu Bsp. 1:} (aus Folie 4.16)
\begin{lstlisting}[language=SQL]
DECLARE @Anz int
SELECT @Anz = COUNT(*)
	FROM Kauf
	WHERE Artnr=5555
IF @Anz > 3
	PRINT 'Anzahl ist ' + CONVERT(CHAR(10), @Anz)
ELSE
	BEGIN
		PRINT 'einzelne Käufe von 5555:'
		SELECT K.Name, K.Vorname
			FROM Kunde K
			JOIN Kauf F ON K.Kunr = F.Kunr
			WHERE Artnr = 5555
	END
\end{lstlisting}
\paragraph{zu Bsp. 2:}$ $
\begin{lstlisting}[language=SQL]
WHILE (SELECT SUM(Kredit) FROM Kunde) < 100000
	BEGIN
		UPDATE Kunde
			SET Kredit = Kredit * 1.1
		IF (SELECT MAX(Kredit) FROM Kunde) > 50000
			BEGIN
				PRINT 'Abbruch > 50000'
				BREAK
			END
	END
\end{lstlisting}
\paragraph{zu Bsp. 3:}$ $
\begin{lstlisting}[language=SQL]
DECLARE @dKredit MONEY,
	@zKredit MONEY
SELECT @zKredit = 10000
SELECT @dKredit = AVG (Kredit)
	FROM Kunde
IF (SELECT Kredit FROM Kunde WHERE Kunr=123) < @dKredit
 UPDATE Kunde SET Kredit = Kredit+@zKredit
\end{lstlisting}

\subsection{Arbeiten mit Batch}
\Folie{4}{17}
\subsection{Arbeiten mit Stored Procedure}
\Folie{4}{18}
\Folie{4}{19}
\paragraph{zu Bsp. 1:} (aus Folie 4.19)
\begin{lstlisting}[language=SQL]
CREATE PROCEDURE Erhoehe_Preis (@Prozent in = 5) AS
	UPDATE Kauf SET vPreis = vPreis + vPreis * @Prozent/100
\end{lstlisting}
\paragraph{zu Bsp. 2:} $ $
\begin{lstlisting}[language=SQL]
-- Aufruf bspw in einem Batch:
EXECCUTE Erhoehe_Preis 10	-- keine Klammern um Paramter im Aufruf!
\end{lstlisting}
\paragraph{zu Bsp. 3:} $ $
\begin{lstlisting}[language=SQL]
CREATE PROC LoescheKu (@Kunr int, @Zaehler int OUTPUT) AS	-- CREATE PROC: Abkürzung für CREATE PROCEDURE
	SELECT @Zaehler = COUNT(*)
		FROM Kauf
		WHERE Kunr = @Kunr
	DELETE FROM Kauf WHERE Kunr = @Kunr
	DELETE FROM Kunde WHERE Kunr = @Kunr	-- Referentielle Integrität: Erst Kauf, dann Kunde löschen!
	
-- Aufruf bspw. im Batch:
DECLARE @Anz int
EXEC LoescheKu 123, @Anz OUTPUT -- OUTPUT muss hier auch noch mal angegeben werden!
PRINT 'Anzahl gelöschter Käufe: ' + CONVERT(CHAR(10), @Anz)
\end{lstlisting}
\Folie{4}{19}

%\newpage
%\printbibliography
\end{document}