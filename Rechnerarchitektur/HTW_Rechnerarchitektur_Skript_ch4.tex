\section*{Hauptspeicher}
\slides{04}{1}
\section{Virtueller Speicher}
\subsection{Ziel}
\slides{04}{2}
\subsection{Virtueller Speicher}
\slides{04}{3}
\subsection{Speicherverwaltung: früher und heute}
\slides{04}{4}
\subsubsection{Begriffe}
\slides{04}{5}
\slides{04}{6}
\slides{04}{7}
\unimptnt{
\subsubsection{Anordnung von Cache und MMU}
\slides{04}{8}
}

\section{Dynamische Zuordnungsverfahren}
\subsection{Relocation}
\slides{04}{9}
\unimptnt{
\subsubsection*{Beispiel}
\slides{04}{10}
}
\subsubsection{Probleme}
\slides{04}{11}
\subsection{Paging}
\subsubsection{Methode}
\slides{04}{12}
\subsubsection{Prinzip der virtuellen Speicherverwaltung}
\slides{04}{13}
\subsubsection{Organisation der Seitentabellen}
\slides{04}{14}

\subsubsection{Einstufige Adressumsetzung}
\slides{04}{15}

\subsubsection*{Adressierung / Adressumsetzung}
\slides{04}{16}
\unimptnt{
\slides{04}{17}
\subsubsection*{Demand Paging}
„Seitennachladen nach Bedarf“: Nur die Seiten (Programmelemente) werden nachgeladen, die benötigt werden.
\subsubsection*{Demand Paging - Page Faults}
\slides{04}{18}
\subsubsection*{Beispiel}
\begin{itemize}
\item 32 Bit virtuelle Adresse ($\to$ 4 GiByte virtueller Adressraum)
\item 1 MiByte ($=2^{20}$ Byte) realer Speicher
\item Seitengröße 4 KiByte ($=2^{12}$ Byte), Adressauflösung: 1 Byte\\
$\Rightarrow$ virtueller Seitennummer 32-12 = 20 Bit\\
$\Rightarrow 2^{20}$ Einträge in der Page Table
\item 1 MiByte Hauptspeicher $\Rightarrow 2^{20-12}=2^8=256$ Seitenrahmen\\
$\Rightarrow$ PTE.Rp benötigt 8 Bit = 1 Byte, 1 weiteres Byte für P, RWX etc.\\
$\Rightarrow$ $2^{20}$ Einträge a 2 Byte $\Rightarrow$ 2 MiByte für Page Table!!! (Konflikt zu 1 MiByte realer Speicher)\\
$\Rightarrow$ PT ebenfalls im virtueller Adressraum, muss auch dem Demand Paging unterliegen…
\end{itemize}
$\Rightarrow$ Dieser Aufwand wird \emph{Table Superfluity} genannt.\bigskip\\
Anderes Szenario:
\begin{itemize}
\item 32 Bit virtuelle Adresse ($\to$ 4 GiByte virtueller Adressraum)
\item 256 MiByte ($=2^{28}$ Byte) realer Speicher
\item Seitengröße 4 KiByte ($=2^{12}$ Byte), Adressauflösung: 1 Byte\\
$\Rightarrow$ virtueller Seitennummer 32-12 = 20 Bit\\
$\Rightarrow 2^{20}$ Einträge in der Page Table
\item 1 MiByte Hauptspeicher $\Rightarrow 2^{28-12}=2^{16}=65.536$ Seitenrahmen\\
$\Rightarrow$ PTE.Rp benötigt 16 Bit = 2 Byte, 1 weiteres Byte für P, RWX etc.\\
$\Rightarrow$ $2^{20}$ Einträge a 3 Byte $\Rightarrow$ 3 MiByte für Page Table\\
$\Rightarrow$ PT kann im realen Hauptspeicher gehalten werden
\end{itemize}
$\Rightarrow$ Dieser Aufwand wird \emph{Table Superfluity} genannt.
}
\subsubsection{Zweistufige Adressumsetzung}
\slides{04}{19}

\subsubsection{Inverted Page Table}
\slides{04}{20}
\unimptnt{
\slides{04}{21}
\subsubsection*{Adressumsetzung}
\slides{04}{22}
\slides{04}{23}
}
\subsection{Segmentation}
\subsubsection{Methode}
\slides{04}{24}
\unimptnt{
\subsubsection{Adressierung / Adressumsetzung}
\slides{04}{25}
}
\subsubsection{Externe Fragmentierung}
\slides{04}{26}
\unimptnt{
\subsubsection{Kompaktierung}
\slides{04}{27}
}

\subsection{Paged Segmentation}
\slides{04}{28}
\unimptnt{
\slides{04}{29}
}

\section{Speicherverwaltungsverfahren}
\subsection{Überblick}
\slides{04}{30}
\subsection{Fetch / Placement}
\slides{04}{31}

\section{Translation Lookaside Buffer}
\slides{04}{32}

\unimptnt{
\subsection{Adressumsetzung}
\slides{04}{33}
}

\subsection{Ansatz}
\slides{04}{34}

\subsection{Probleme}
\slides{04}{35}
\unimptnt{
\slides{04}{36}
}
$\Rightarrow$ In modernen Systemen mit stets wechselnden Prozessen lohnt sich kein zu großer TLB, da er mit jedem Prozess neu beschrieben wird. Wird also der Prozess gewechselt, was regelmäßig geschieht, ist der gesamte TLB ungültig… obwohl der vorhergehende Prozess ihn wahrscheinlich gar nicht komplett füllen konnte.