%\subsection*{Speicherverwaltung: Einführung}
\slides{03}{2}
\section{Speicherhierarchie}
\slides{03}{3}

\subsection{Ebenen}
\slides{03}{4}
\slides{03}{5}

\section{Cache}
\subsection{Einführung}
\subsubsection{Motivation und Grundidee}
\slides{03}{6}

\subsubsection{Umsetzung der Idee}
\slides{03}{7}
\slides{03}{8}

\subsubsection{Hierarchie, Übertragungsmodi}
\slides{03}{9}

\subsection{Lokalität}
\subsubsection{Prinzip}
\slides{03}{10}
Beispiel Lokalität: Wenn man bei C Arrays multipliziert, kann je nach Schachtelung der Schleifen die Laufzeit leiden. In C werden Arrays zeilenweise gespeichert, multipliziert man die Arrays allerdings spaltenweise, so muss viel gesprungen werden, da die Speicherblöcke weiter auseinander liegen.

\subsubsection{Zeitliche Lokalität}
(Temporal Locality)
\slides{03}{11}

\subsubsection{Räumliche Lokalität}
(Spatial Locality)
\slides{03}{12}

\subsubsection{Bedeutung der Lokalität}
\slides{03}{13}

\subsubsection{Umsetzung des Lokalitätsprinzips}
\slides{03}{14}

\subsection{Zugriff}
\subsubsection{Anordnung bezüglich CPU und Hauptspeicher}
\slides{03}{15}
\subsubsection{Fehlzugriffe}
\slides{03}{16}
weiterhin:
\slides{03}{17}
\subsubsection*{Compulsory-Miss}
\slides{03}{18}

\subsubsection{Lesezugriffe}
\slides{03}{19}

\subsubsection{Schreibzugriffe}
\subsubsection*{Rückschreibestrategien}
\slides{03}{20}
\subsubsection*{Durchschreibverfahren}
\slides{03}{21}
\subsubsection*{Rückschreibeverfahren}
\slides{03}{22}
\subsubsection*{Write Hit und Write Miss}
\slides{03}{23}

\subsection{Kohärenz und Konsistenz}
\subsubsection{Kohärenz}
„Alle Speicherzugreifenden bekommen den richtigen Wert, wenn sie auf den Speicher zugreifen“
\unimptnt{
\subsubsection*{Kohärenz Beispiel mit Write-Through-Caches}
\slides{03}{24}
\subsubsection*{Kohärenz Beispiel mit Write-Back-Caches}
\slides{03}{25}
}

\subsubsection*{Speicherkohärenz}
\slides{03}{26}

\subsubsection*{Definition Kohärenz}
\slides{03}{27}
\slides{03}{28}

\subsubsection{Konsistenz}
\slides{03}{29}

\unimptnt{
\subsubsection*{Speicher-Konsistenz}
\slides{03}{30}
}

\subsubsection{Kohärenz-Protokolle}
\slides{03}{31}
\unimptnt{
\subsubsection*{Vereichnisbasiert}
\slides{03}{32}

\subsubsection*{Bus-Snooping}
\slides{03}{33}

Möglichkeiten:
\slides{03}{34}

\subsubsection*{MESI-Kohärenzprotokoll}
\slides{03}{35}
Verbesserungen:
\slides{03}{36}

\subsubsection*{Update-basierte Protokolle}
\slides{03}{37}
}

\section{Cacheorganisation}

\subsection{Realisierung}
\slides{03}{38}

\subsection{Aufbau eines Cache-Speichers}
\slides{03}{39}

\subsection{Begriffe}
\slides{03}{40}

\subsection{Direktabbildender Cache}
(Direct Mapped Cache)
\slides{03}{41}
Beispiel: Direkt abgebildeter Cache mit 8 Einträgen, Speicher mit $2^5$ Adressen: Die letzten Bits der Speicheradressen bestimmen die Position im Cache: $00001$, $01001$, $10001$ und $11001$ landen im Cache-Block $001$.
\unimptnt{
\slides{03}{42}
}

\subsection{vollassoziativer Cache}
(Fully Associative Cache)
\slides{03}{43}

\subsection{p-fach satzassoziativer Cache}
\slides{03}{44}
\unimptnt{
\slides{03}{45}

\subsection{Cache-Mapping: zusammenfassendes Beispiel}
\slides{03}{46}
Die 2. und 3. Caches geben dem Cache also eine Struktur vor, die die Nachteile des voll-assoziativer Caches versuchen abzumildern.
}

\section{Leistungssteigerung durch Cache}

\slides{03}{47}
\slides{03}{48}
\unimptnt{
\slides{03}{49}
}

\subsection{Gesamtgröße und Block(rahmen)größe}
\slides{03}{50}
\unimptnt{
\subsubsection{Einfluss der Blockrahmengröße}
\slides{03}{51}
}

\section{Nachladestrategien}
\subsection{Demand Fetching}
\slides{03}{52}
\subsection{Prefetching}
\subsubsection*{Was}
\slides{03}{53}
\subsubsection*{Wann}
\slides{03}{54}
\unimptnt{
\slides{03}{55}
}
Tagged Prefetch: Es wird nur weiter nachgeladen, wenn es sich zuvor „gelohnt“ hat ($\to$ ein Hit vorhanden war)

\section{Verdrängungsstrategien}
(Replacement Policy)
\slides{03}{56}
\subsection{Random, FIFO, Round Robin}
\slides{03}{57}
\subsection{LFU}
\slides{03}{58}
\subsection{LRU}
\slides{03}{59}
\unimptnt{
\subsubsection{Algorithmus}
\slides{03}{60}
}