\newcommand{\customDir}{../}
\input{\customDir _LaTeX_master/LaTeX_master_setup.sty}

%\setboolean{twosided}{true}
%\setCustomDocumentClass{scrartcl}
%\setCustomDesign{htw}
\setCustomSlidePath{Vorlesung/CG1-01-15-neu}

\setCustomTitle{Computergrafik 1}
\setCustomSubtitle{Vorlesungsskript}
\setCustomAuthor{Falk-Jonatan Strube}
%\setCustomNoteA{TitlepageNoteBeforeAuthor}
\setCustomNoteB{Vorlesung von Prof. Dr.-Ing. habil. Oertel}

%\setcustomSignature{\footnotesize{\textcolor{darkgray}{Mitschrift von\\ \customAuthor}}	% Formatierung der Signatur in der Fußzeile
%\setcustomTitleAuthor{\textcolor{darkgray}{Mitschrift von #1}}	% Formatierung des Autors auf dem Titelblatt

\input{\customDir _LaTeX_master/LaTeX_master.sty}
\input{\customDir _LaTeX_master/LaTeX_master_macros.sty}

%\bibliography{\customDir _Literatur/HTW_Literatur.bib}

%\renewcommand{\unimptnt}[1]{}

\begin{document}

%\selectlanguage{english}
\maketitle
\newpage
\tableofcontents
\newpage

\unimptnt{
\chapter*{Vorbemerkung}
Prüfung: alle Unterlagen erlaubt (Skripte, Bücher usw.)\\
2 Teile: 1/2 Praxis (erste Hälfte der VL), 1/2 „Theorie“ (zweite Hälfte der VL)\\
Belegabgabe: Ende der Vorlesungszeit (03.02.2016), Vorabgabe (vorm Einreichen) im Praktikum
% Passwort: WSEM2016
%\slide{2}

Folien mit +: wichtige Folien
}
\chapter*{Grundbegriffe}
\unimptnt{
\slide{3}
}
\section*{Systematisierung}
\slide{4}

\chapter{OpenGL: Anwendung und Programmierung}
\unimptnt{\slide{5}
\section{Systemarchitektur}
\slide{6}
\subsection{Interaktive generative grafische Systeme}
\slide{7}
\subsection{Grafische Datenstrukturen}
\slide{8}
\subsection{Weg und Ziel}
\slide{9}
3. Bild: Schattierung (keine Schattenbildung, sondern „Einfärbung“ von Seiten)
}
\section{OpenGL}
\slide{10}
\unimptnt{
\subsection{Versionen}
\slide{11}
\subsection{OpenGL Core Profile}
\slide{12}
Eckpunkte -> Vertex Shader -> Fragment Shader -> Framebuffer
}
\subsection{Grafik-Bibliotheken}
\slide{13}
\subsection{Initialisierung}
\slide{14}

\section{Renderpipeline}
\slide{15}
\subsection{Sequentielle Struktur}
\slide{16}
\unimptnt{
\slide{17}
}
\section{Rahmenprogramm}
\subsection{Client-Seite}
\slide{18}
\slide{19}
\subsection{Server-Seite}
\slide{20}

\section{Hauptprogramm}
\subsection{Sprachsyntax}
\slide{21}

\section{Funktionsreferenz}
\subsection{Funktionen GL}
\slide{22}
\unimptnt{
\slide{25}
}
\subsection{Funktionen GLUT}
\slide{23}
\unimptnt{
\slide{24}
}

\chapter{OpenGL: Shader und Programmierung}
\unimptnt{
\slide{28}
}
\section{Vorgehensweise}
\slide{29}
Fragment-Shader als Rasterisierung eines Bildes (bspw. Vektor-Strich von A nach B) und dann Zuweisung der Farbe den entsprechenden Rasterelementen/Pixel\\
Vertex-Shader guckt sich dem entgegen Eckpunkte an.
\section{Shader-Einbindung}
\slide{30}
\subsection{Programmbeispiele}
\slide{32}
\unimptnt{
\subsection{Funktionen}
\slide{31}
}

\section{Rasterisierung und obligatorischer Shader}
\unimptnt{
Aufgabe: Behandlung und Verarbeitung von Eckpunktdaten und Pixeldaten sowie deren Überführung
ineinander; Transformation zwischen Hauptprogramm und Frame Buffer.
\subsection{Rasterisierung}
\slide{33}
}
\subsection{Vertex-Shader}
\slide{34}
\subsection{Fragment-Shader}
\slide{35}
\unimptnt{
\subsection{Beispiele}
\slide{36}
}

\section{Shader-Sprache}
\slide{37}
\subsection{Operatoren und Ausdrücke}
\slide{38}
\slide{39}
\subsection{Qualifikatoren}
\slide{40}
\slide{41}
\slide{42}

\subsection{Vordefinierte Funktionen}
\slide{43}
\slide{44}

\subsection{Vordefinierte Variablen}
\slide{45}
\slide{46}

\subsection{Programmbeispiele}
\slide{47}
\slide{48}

\section{Programm- und Datenübergabe}
\unimptnt{
\slide{49}
}
\subsection{Interface Blöcke}
\slide{50}
\unimptnt{
\section{Funktionsreferenz}
\slide{51}
\slide{52}
}

\chapter{OpenGL: Zeichnung und Daten}
\unimptnt{
\slide{54}
}

\section{Vorgehensweise}
\slide{55}

\section{Zeichenprimitive}
\slide{56}

2,5\,D Geometrie: die 3. Dimension nur senkrecht zu einer Fläche (bspw. Bildschirm)

\subsection{Punkte, Linien}
\slide{57}

\subsection{Dreiecke}
\slide{58}

\subsection{Darstellungsattribute}
\slide{59}

\subsection{Programmeinbindung der Zeichenprimitive}
\subsubsection*{Befehlsfolge:}
\slide{60}

\section{Zeichenfarben}
\slide{61}
zeigt NUR im Fragmentshader Wirkung
\subsection{Farbe als Attribut}
\slide{62}
\subsection{Schattierungsarten}
\slide{63}
\subsection{Programmeinbindung der Vordergrundfarbe}
\subsubsection*{Befehlsfolge:}
\slide{64}

\section{Pufferobjekte}
\slide{65}
\unimptnt{
\slide{66}
\slide{67}
}
\subsection{Programmbeispiele}
\subsubsection*{Interpolation von Eckpunkten und Farben zweier Dreiecke}
\slide{68}
\slide{69}
\subsubsection*{Zeichenvarianten eines Dreiecks}
\slide{70}
\subsubsection*{Indexierte Zeichnung eines Würfels}
\slide{71}
\slide{72}

\unimptnt{
\section{Polygone und Netze}
\subsection{Quadriken}
\slide{73}
\subsection{Evaluatoren}
\slide{74}

\section{Funktionsreferenz}
\slide{75}
\slide{76}
\slide{77}
\slide{78}
}
\chapter{OpenGL: Pixel und Puffer}
\unimptnt{
\slide{79}
}
\section{Pufferstrukturen}
\slide{80}
\section{Pufferoperationen}
\slide{81}
\begin{itemize}
\item glClearColor(): Hintergrundfarbe, zu Beginn der display() Funktion, es sei denn für Effekte
\item glClearDepth(): Tiefenpuffer , zu Beginn der display() Funktion, es sei denn für Effekte
\end{itemize}
Maskieren wird nach dem Fragmentshader verwendet.
\begin{itemize}
\item Scissor-Test: In der Regel Rechtecke (Schnittrechteck)
\item Multi-Sample-Operations: Subpixel
\item Stencil-test: Maske/Schablone
\item Depht Buffer Test: verdeckte pixel werden nicht gerendert
\item Blending: später
\item Logic Operations: z.B. Transparenz
\item Dithering: Räumliche/Farbliche Auflösung
\end{itemize}
\subsection{Tests und Operationen für Fragmente}
\subsubsection{Scissor-Test, Multisampling-Fragment-Operationen, Stencil-Test}
\slide{82}
glScissor(x,y,w,h) (Ursprung, Länge, Höhe: Nur alles was in diesem Feld enthalten ist wird angezeigt
\subsubsection{Depth-Test, Dithering, Logic}
\slide{83}
GL\_ LESS Objekte die kleiner sind als der eingestellte wert werden nicht gerendert
\begin{lstlisting}[language=C++]
init(){
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(func);
	glPolygonOffset(factor units);
}

display()
{
	glClear(GL_DEPTH_BIT);
	...
}
\end{lstlisting}
mit glPolygonOffset() kann sichergestellt werden das eine Kante um ein Objekt sichtbar wird.
\subsubsection{Blending}
\slide{84}
Transparenz: GL\_SRC\_ALPHA, GL\_ONE\_MINUS\_SRC\_ALPHA\\
Beispiel:$\alpha_q = 0.7 \Rightarrow 0.5*0.7+0.2*0.3 = 0.$
\unimptnt{
\subsubsection*{Funktionen für Blending}
\slide{85}
\subsubsection{Verdeckungsabfrangen, bedingtes Rendern}
\slide{86}
\subsection{Antialiasing}
\slide{87}
\subsubsection{Multisampling}
\slide{88}
}
\subsubsection*{Programmbeispiel}
Räumlich beschränkte / tiefengerechte / transparente Ausgabe:
\slide{89}
\unimptnt{
\section{Framebuffer Objekte}
\slide{90}
\section{Multiple Renderbuffer}
\slide{91}
\section{Lesen und Kopieren von Pixeldaten}
\slide{92}
\subsection*{Beispiel}
Zugriff auf Renderbuffer:
\slide{93}

\section{Funktionsreferenz}
\slide{94}
\slide{95}
\slide{96}
}

\chapter{OpenGL: Ansicht und Transformation}
\unimptnt{
\slide{97}
}

\section{Modelle und Operationen}
\unimptnt{
\slide{98}
}

\subsection{Kamera Analogie und Geometrie Pipeline}
\slide{99}
\unimptnt{
\subsection{Vektoren und Matrizen}
\slide{100}
}
\subsection{Koordinatensysteme}
\slide{101}

\section{Transformation}
\slide{102}

\section{Projektion}
\slide{103}

\section{Viewport}
\slide{104}

\section{Matrizen}
\slide{105}
\unimptnt{
\slide{106}
}
\section{Bibliotheksoperationen}
\slide{109}

\subsection{Programmbeispiele}
\slide{110}
\slide{111}

\section{Transformationsrückkopplung}
\unimptnt{
\slide{112}
\subsection{Programmbeispiel}
\slide{113}

\section{Funktionsreferenz}
\slide{114}
\slide{115}
\slide{116}
}

\chapter{OpenGL: Bild und Textur}
\unimptnt{
\slide{117}
}

\section{Arbeit mit Bildern}
\slide{118}

\subsection{Programmbeispiele}
\slide{119}

\section{Grundlegende Texturierungsverfahren}
\slide{120}

\section{Anlegen und Verwenden von Texturen}
\slide{121}

\subsection{Texturfunktionen}
\slide{122}

\subsection{Texturkoordinaten}
\slide{123}

\subsection{Texturfilter}
\slide{124}

\unimptnt{
\subsection{Sampler und multiple Texturen}
\slide{125}
}

\subsection{Programmbeispiele}
\slide{126}
\slide{127}
\slide{128}

\unimptnt{
\section{Aufbauende Texturierungsverfahren}
\slide{129}
\slide{130}
\slide{131}
\slide{132}

\section{Programmbeispiele}
\slide{133}
\slide{134}

\section{Verwendete Funktionen}
\slide{135}
\slide{136}

\section{Funktionsreferenz}
\slide{137}
\slide{138}
\slide{139}
\slide{140}
\slide{141}
\slide{142}
}

\chapter{OpenGL: Licht und Schatten}
\unimptnt{
\slide{143}
}

\section{Lichtquelle}
\slide{144}

\subsection{Definition von Lichtquellen mit Parametern}
\slide{145}

\section{Material}
\slide{146}
\unimptnt{
\slide{147}
}

\section{Beleuchtungsrechnung}
\slide{148}
\subsection{Beleuchtungssituation}
\slide{149}
\subsection{Beleuchtungsberechnung}
\slide{150}

\section{Normalenvektor}
\slide{151}

\section{Fog}
\slide{152}

\section{Shaderbasierte Beleuchtung}
\slide{153}

\section{Programmbeispiele}
\subsection{Ambientes Licht}
\slide{154}
\slide{155}
\slide{156}
\subsection{Richtungslicht}
\slide{157}
\subsection{Punktlicht und Spotlicht}
\slide{158}
\slide{159}

\section{Mehrere Materialien und Lichtquellen}
\slide{160}

\unimptnt{
\section{Globale Beleuchtungsmodelle}
\slide{161}
}

\chapter{Shader und Technologie}
\unimptnt{
\slide{162}
}

\section{Shader-Gesamtkonzept}
\slide{163}
\subsection{Render-Pipeline}
\slide{164}
\unimptnt{
\subsection{Speicherorganisation}
\slide{165}
\subsection{Programmbeispiel}
\slide{166}
}

\section{Tesselations Shader}
\slide{167}
\unimptnt{
\section{Programmbeispiel}
\slide{168}
}

\section{Geometry Shader}
\slide{169}
\subsection{Programmbeispiel}
\slide{170}

\unimptnt{
\section{Compute Shader}
\slide{171}
\subsection{Programmbeispiel}
\slide{172}

\section{Funktionsreferenz}
\slide{173}
\slide{174}
\slide{175}
}

\chapter{Geometrie und Transformation}
\unimptnt{
\slide{176}

\section{Affine Räume}
\slide{177}
\slide{178}
}

\section{2D Koordinatensysteme}
\slide{179}
\section{Elementare 2D-Transformationen}
\slide{180}
\subsection{2D-Transformation in homogene Koordinaten}
\slide{181}

\section{Komposite 2D-Transformationen}
\slide{182}
\unimptnt{
\subsection{Beispiele}
\slide{183}
}

\section{3D Koordinatensysteme}
\slide{184}

\section{Elementare 3D-Transformationen}
\slide{185}
\unimptnt{
\slide{186}
\slide{187}

\section{Komposite 3D-Transformationen}
\slide{188}
}

\section{Wechsel von Koordinatensystemen}
\slide{189}
\unimptnt{
\subsection{Beispiele}
\slide{190}
}

\chapter{Geometrie und Projektionen}
\unimptnt{
\slide{191}

\section{Projektive Räume}
\slide{192}
}

\section{Projektion}
\slide{193}
\unimptnt{
\subsection{Perspektivische Projektion}
\slide{194}
}
\subsection{Parallele Projektion}
\slide{195}

\section{Spezifikation von 3D-Sichten}
\slide{196}
\slide{197}

\section{Beispiele für 3D-Sichten}
\slide{198}
\slide{199}

\section{Formale Darstellung von Projektionen}
\slide{200}
\unimptnt{
\subsection{Allgemeine Projektion}
\slide{201}

\subsection{Normalisierung von Sichtvolumen}
\slide{202}
\slide{203}
}
\subsection{Projektionsarten}
\slide{204}
\subsection{Projektion mit Sichtvolumen}
\slide{205}

\unimptnt{
\section{Implementation von Projektion}
\slide{206}
}
%\newpage
%\printbibliography

\end{document}