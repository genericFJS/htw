\newcommand{\customDir}{../}
\input{\customDir _LaTeX_master/LaTeX_master_setup.sty}

%\setboolean{twosided}{true}
%\setCustomDocumentClass{scrartcl}
%\setCustomDesign{htw}
\setCustomSlidePath{Vorlesung/VO}
\setCustomSlideScale{1.5}

\setCustomTitle{Software Engineering 1}
\setCustomSubtitle{Vorlesungsskript}
\setCustomAuthor{Falk-Jonatan Strube}
%\setCustomNoteA{TitlepageNoteBeforeAuthor}
\setCustomNoteB{Vorlesung von Prof. Dr. Hauptmann}

%\setcustomSignature{\footnotesize{\textcolor{darkgray}{Mitschrift von\\ \customAuthor}}	% Formatierung der Signatur in der Fußzeile
%\setcustomTitleAuthor{\textcolor{darkgray}{Mitschrift von #1}}	% Formatierung des Autors auf dem Titelblatt

\input{\customDir _LaTeX_master/LaTeX_master.sty}
\input{\customDir _LaTeX_master/LaTeX_master_macros.sty}

%\bibliography{\customDir _Literatur/HTW_Literatur.bib}

\begin{document}

%\selectlanguage{english}
\maketitle
\newpage
\tableofcontents
\newpage
\chapter*{Vorbemerkung}
2 Teile (jeweils 50 Punkte)
\begin{itemize}
\item Praktikum (kleine Anforderungsanalyse, vgl. Belegarbeit)
\item Vorlesung (Fragen, wie sie auch auf den Folien formuliert sind)
\end{itemize}
Extra-Punkte für Klausur:\\
Analyse, wie man das gelernte aus der Veranstaltung SE 1 auf andere Fächer, Bereiche usw. anwenden konnte (spezifisch). Ca. eine Seite.\\
Per Email an Frau Hauptmann. Betreff: Reflexion SE 1 IA

\chapter{Einführung}
\slides{1}{3}

\section{Gliederung}
\slides{1}{5}
\slides{1}{6}

\section{Die ersten Phasen}
\slides{1}{14}
\begin{itemize}
\item Wie werden Softwaresysteme entwickelt?
\item Was ist Software-Engineering?
\item Warum haben Analyse und Definition von Anforderungen an das SW-System große Bedeutung im Entwicklungsprozess?
\end{itemize}

\section{Vergleich Bauingenieur und Softwareentwicklung}
\slides[2]{1}{16}
Begleitend:
\begin{itemize}
\item Projektleiter
\item technischer Autor
\item Qualitäts-Beauftragter
\end{itemize}
Zertifizierung für Software: IREB
\slides{1}{17}

\section{Erfolgsquote von Software-Projekten gestern und heute}
\slides{1}{19}
Also: Analyse ist Grundvoraussetzung für erfolgreiche Softwareentwicklung.

Veranschaulichung:
\slides{1}{20}
Warum haben Analyse und Definition von Anforderungen an das SW‐System große Bedeutung
im Entwicklungsprozess?
\begin{itemize}
\item Auch heute noch werden nur die Hälfte aller SW‐Projekte wie geplant realisiert.
\item 60\% der Fehler im SW‐System resultieren aus Fehlern in der Analysephase, d.h. aus Fehlern bei der Definition der Anforderungen.
\item Die Behebung von Fehlern aus der Analysephase sind vergleichsweise sehr teuer.
\end{itemize}

\section{Definitionen Software Engineering}

\slides{1}{22}
\slides{1}{23}
\slides{1}{24}
Also:

\paragraph{Software-Engineering ist}
\begin{itemize}
\item die effektive und effiziente Entwicklung und Weiterentwicklung komplexer SW-Systeme
\item sowie begleitender Dokumente
\item in einem bewusst arbeitsteilig gestalteten Prozess
\item unter Anwendung bewährter Prinzipien, Methoden und Modellen.
\end{itemize}
oder Vergleich:
\slides{1}{25}
%\begin{itemize}
%\item $\Rightarrow$ nützt nichts, sondern verhindert vielmehr Schäden $\to$ sollte generell beachtet werden
%\item „Software Engineering ist -- wie die Hygiene in der Medizin -- langweilig und frustrierend für Leute, die die Abwehr von Fehlschlägen und Katastrophen nicht als positive Leistung betrachten.“
%\end{itemize}
\begin{itemize}
\item sauberes Arbeiten (vgl. Chirurg: kann auch so operieren, wenn er aber ohne Hygiene operiert, ist der Ausgang ungewiss)
\item „Wenn's nicht funktioniert, ist man immer wieder damit beschäftigt die gleichen Fehler zu bearbeiten.“
\end{itemize}

\setCustomSlideScale{.95}
\slides{1}{26}

\chapter{System}

\paragraph{Wie werden Software-Systeme entwickelt?}
\begin{itemize}
\item Bevor mit der Implementierung begonnen wird, werden die Anforderungen ermittelt und beschrieben.
\item Danach wird ausgehend von der Beschreibung der Anforderungen eine Struktur festgelegt, nach der SW-System gebaut wird.
\item Erst dann beginnt die Implementierung.
\item Dabei begleiten ständig Tests und Dokumentation die Arbeit.
\end{itemize}
\paragraph{Was ist „Software‐Engineering“?} (siehe weitere Definitionen)\\
Software‐Engineering ist:
\begin{itemize}
\item die effektive und effiziente Entwicklung und Weiterentwicklung \emph{komplexer} SW-Systeme
\item sowie \emph{begleitender Dokumente}
\item in einem bewusst arbeitsteilig gestalteten \emph{Prozess}
\item unter Anwendung bewährter \emph{Prinzipien, Methoden und Modellen}.
\end{itemize}
\paragraph{Warum haben Analyse und Definition von Anforderungen an das SW‐System große Bedeutung
im Entwicklungsprozess?}
\begin{itemize}
\item Auch heute noch werden nur die Hälfte aller SW‐Projekte wie geplant realisiert.
\item 60\% der Fehler im SW‐system resultieren aus Fehlern in der Analysephase, d.h. aus Fehlern in der Definition der Anforderungen.
\item Die Behebung von Fehlern aus der Analysephase sind vergleichsweise sehr teuer.
\end{itemize}

% Vorlesung 20.10.2016
\setCustomSlideScale{.5}
% \slides{2}{1}

\section{Entwicklung von SW-Entwicklungsstrategien}
Problem der SW-Entwicklung am Ende der 60‐ziger Jahre:\\
veränderte Rahmenbedingungen beim Einsatz und der Entwicklung von Software-Systemen\\
Also: Strategien bei der SW-Entwicklung ändern

\section{Definition Softwaresystem}
\subsection{Was kennzeichnet ein System?}
\begin{itemize}
\item Gesetzmäßigkeiten (Regeln, …) im Inneren, damit es funktioniert [Wenn es ein Innen gibt, muss es auch ein Außen geben]
\item $\Rightarrow$ Ein System besteht aus Komponenten, die Beziehung zueinander haben.
\end{itemize}
\begin{center}
\begin{tikzpicture}[thick, scale=0.6]
\draw  (-11,7) rectangle (11,-11);
\draw  (0,-2) ellipse (8 and 8);
\begin{scope} [xshift=-90, yshift=90,rotate=45]
\fill [white] (-2,2) ellipse (1 and 0.5);
\draw  (-2,2) ellipse (1 and 0.5);
\draw [-latex] (-2.5,1) -- (-2.5,3);
\draw [latex-] (-1.5,1) -- (-1.5,3);
\end{scope}
\begin{scope} [xshift=170, yshift=10,rotate=-45]
\fill [white] (-2,2) ellipse (1 and 0.5);
\draw  (-2,2) ellipse (1 and 0.5);
\draw [-latex] (-2.5,1) -- (-2.5,3);
\draw [latex-] (-1.5,1) -- (-1.5,3);
\end{scope}
\begin{scope} [xshift=250, yshift=-210,rotate=45]
\fill [white] (-2,2) ellipse (1 and 0.5);
\draw  (-2,2) ellipse (1 and 0.5);
\draw [-latex] (-2.5,1) -- (-2.5,3);
\draw [latex-] (-1.5,1) -- (-1.5,3);
\end{scope}
\begin{scope} [xshift=-170, yshift=-290,rotate=-45]
\fill [white] (-2,2) ellipse (1 and 0.5);
\draw  (-2,2) ellipse (1 and 0.5);
\draw [-latex] (-2.5,1) -- (-2.5,3);
\draw [latex-] (-1.5,1) -- (-1.5,3);
\end{scope}
\node at (-9,5) {Person A};
\node at (-8,-9) {anderes System};
\node at (8,-9) {Person B};
\node at (8,5) {…};
\draw  (-5,2) rectangle (-1,0) node[pos=.5]{Kompenente};
\draw  (2,1) rectangle (4,-1);
\draw  (-5,-4) rectangle (-2,-6);
\draw  (2,-5) rectangle (4,-7);
\draw  (-2,-7) rectangle (0,-9);
\draw (-4,0) -- (-4,-4);
\draw (-1,1) -- (2,0);
\draw (-2,0) -- (3,-5);
\draw (0,-8) -- (2,-6);
\draw (-3,-6) -- (-2,-8);
%\draw (-3,0) -- (-1,-4) -- (-1,-7);
\draw plot[smooth, tension=0.5] coordinates {(-3,0) (-1.5,-3.5) (-1,-7)};
\end{tikzpicture} % ABB SE2
\end{center}
\subparagraph{VDI 3633 Blatt 1: System} ( VDI = Verein Deutscher Ingenieure)
\slides{2}{6}
\slides{2}{7}

Also:
\begin{itemize}
\item Ein System besteht aus Komponenten, die miteinander in Beziehung stehen.
\item Eine Grenze trennt das System von seiner Umgebung (auch Kontext genannt).
\item Schnittstellen (Verbindungsstellen) verbinden das System mit seiner Umwelt.
\item Ein System kann Subsysteme enthalten. Ein System befindet sich zum Zeitpunkt t in einem def. Zustand.
\end{itemize}


\subsection{Warum sind Software-Systeme ganz spezielle Systeme?}
\begin{itemize}
\item SW-Systeme sind „immateriell“ und komplex; sie haben keine natürliche Lokalität.
\item SW-Systeme sind aus einem Werkstoff hergestellt, der von sich aus keine Strukturierung im „Großen“ erfordert (Sprich: niemand wird „gezwungen“ die Software zu strukturieren, es ist aber wohl hilfreich).
\end{itemize}

\subsection{Welchen Unterschied gibt es zwischen Modellen und Prototypen bei der Software-Entwicklung?}
\subparagraph{VDI 3633 Blatt 1: Modell}
\slides{2}{10}
\slides{2}{11}
Softwareprojekte können aufgrund ihrer Komplexität niemals nur durch ein Modell abgebildet werden, sondern brauchen mehrere!
\begin{itemize}
\item Modelle bilden ab.
\item Prototypen sind lauffähig.
\end{itemize}

\subsection{Welche Grundprinzipien finden in der SW-Entwicklung Anwendung?}
\begin{itemize}
\item Abstraktion
\slides{2}{15}
\item Strukturierung
\item Zerlegung
\slides{2}{17}
Entwicklerdokumentation braucht auch ein grobe Übersicht (nicht nur Doxygen generiertes)
\item Kapselung
\slides{2}{18}
\item Hierarchisierung
\slides{2}{16}
\item Standardisierung
\item (integrierte) Dokumentation\\
$\Rightarrow$ Weitergabe von Wissen
\slides{2}{22}
\end{itemize}
weitere:
\begin{itemize}
\item Typisierung
\slides{2}{19}
\item Nebenläufigkeit
\slides{2}{20}
\item Persistenz
\slides{2}{21}
\end{itemize}
Also: 
\begin{itemize}
\item Abstraktion 
\item Strukturierung
\item Zerlegung
\item Kapselung
\item Hierarchisierung
\item Standardisierung
\item integrierte Dokumentation
\end{itemize}
$\Rightarrow$ Mittel um Komplexität zu beherrschen

\chapter{Qualität von Software-Systemen}
\section{Was kennzeichnet qualitativ hochwertige Software-Systeme?}
\paragraph{Gedanken:}
\begin{itemize}
\item stabil laufen
\item wenig Fehler
\item erfüllt seine Funktion
\item intuitiv und einfach benutzbar
\item kompatibel
\item wenig Ressourcenverbrauch (effizient)
\item schöne Oberfläche (Achtung, hier wird klar: Qualität kann auch subjektiv sein)
\item transparenter Systemzustand (z.B. aussagefähige Statusmeldungen)
\item …
\end{itemize}
\paragraph{Lösung:}
\begin{itemize}
\item Funktionserfüllung
\item Benutzerfreundlichkeit
\item Wirtschaftlichkeit
\item Je nach gesetzten Prioritäten:
\begin{itemize}
\item Zuverlässigkeit
\item Sicherheit
\item Flexibilität (Änderbarkeit, Erweiterbarkeit, Portabilität, Kompatibilität)
Wiederverwendbarkeit
\end{itemize}
\end{itemize}

\slides{3}{2}
Qualität hat mehrere Sichten:
\begin{itemize}
\item Benutzersicht (Außen)
\item Entwicklersicht (Innen)
\end{itemize}
\slides{3}{3}
\slides{3}{4}
\paragraph{Wann weiß man, ob das SW-System seine Funktion gut erfüllt?}
Übereinstimmung von \emph{geplanter} (spezifiziert z.B. im Pflichtenheft) und realisierter Funktionalität.

\section{Qualitätsmerkmale}

\subsection{Benutzungsschnittstelle} (DIN EN ISO 9241-110)\\
„Alle Bestandteile eines interaktiven Systems (Software oder Hardware), 
die Informationen und Steuerelemente zur Verfügung stellen,
die für den Benutzer notwendig sind,
um eine bestimmte Arbeitsaufgabe mit dem interaktiven System zu erledigen.“

\subsection{Usability} (DIN EN ISO 9241-110)\\
„Ausmaß, in dem ein System, ein Produkt oder eine Dienstleistung
durch bestimmte Benutzer in einem bestimmten Nutzungskontext genutzt werden kann,
um festgelegte Ziele effektiv, effizient und zufriedenstellend zu erreichen.“

\subsection{User Centered Design} (DIN EN ISO 9241-210)
\slides{3}{6}
\begin{itemize}
\item Erreichbar gut über Prototypen, schon vor Beta-Tests
\end{itemize}
\paragraph{Benutzbarkeit} \parskp
Achtung: Subjektiv (es gibt auch objektive Regeln); gestützt durch Oberflächenprototyp (Check-Dummy)

\subsection{Effizienz} 
\begin{itemize}
\item Speicherausnutzung
\item Transport
\item Antwortzeit (durch bessere Algorithmen (bspw. Sortierung))
\end{itemize}

\subsection{Zuverlässigkeit}
\begin{itemize}
\item Fehlerfrei $\to$ Vermeidung von Ausfällen
\end{itemize}

\begin{tikzpicture}[scale=.5]
\draw [-latex] (0,0) -- (0,10) node[left]{$\lambda$ (Ausfallrate)};
\draw [-latex] (0,0) -- (10,0) node[below]{$t$};

\draw (1,7) -- (3,1) -- (8,1) -- (10,7);
\node at (3,0) [below] {$t_1$};
\node at (8,0) [below] {$t_2$};
\end{tikzpicture}
\begin{itemize}
\item Frühausfälle durch Produktionsfehler $t_1$
\item Spätausfälle durch physischen Verschleiß $t_2$
\end{itemize}

\begin{tikzpicture}[scale=.5]
\draw [-latex] (0,0) -- (0,10) node[left]{$\lambda$ (Ausfallrate)};
\draw [-latex] (0,0) -- (10,0) node[below]{$t$};

\draw (1,7) -- (3,1) -- (8,1) -- (10,7);
\node at (3,0) [below] {$t_1$};
\node at (8,0) [below] {$t_2$};
\draw (11,8) -- (12,8)  node[right]{Hardware $\to$ Badewannenkurve};
\draw [blue] (11,6) -- (12,6)  node[right]{Software (ideal)};
\draw [orange] (11,4) -- (12,4)  node[right, align=left]{Software (real möglich: \\ Fehler behoben oder „zu Tode gepflegt“)};
\draw [blue] plot[smooth, tension=0.5] coordinates { (1,7) (4,2) (7,1) (10,0.75)};
\draw [orange] (1,7) -- (3,5) -- (5,6);
\draw [orange] (3,5) -- (5,4);
\end{tikzpicture}

\subsection{Sicherheit}
\begin{itemize}
\item Vermeidung von gefährlichen Zuständen
\end{itemize}

Mögliche Lösung/Herangehensweise für Zuverlässigkeit und Sicherheit:\\
Redundanz!

\subsection{Erweiterbarkeit}
\begin{itemize}
\item neue Funktionalität kommt hinzu $\to$ welcher Aufwand resultiert daraus?
\end{itemize}

\subsection{Anwendbarkeit}
\begin{itemize}
\item gleiche Funktionalität mit anderen Eigenschaften z.B. kürzere Antwortzeit
\end{itemize}

\subsection{Kompatibilität}
Kompatibel $\to$ anschließbar
\begin{itemize}
\item Das SW-System A muss zusammen mit dem SW-System B arbeiten.
\end{itemize}

\subsection{Portabilität}
Portabel $\to$ „fortschleppbar“
\begin{itemize}
\item Das SW-System A läuft in der Umgebung von 1 bzw. 2 (Plattform) [Linux bzw. Windows]
\end{itemize}


\section{Wie kann hohe Software-Qualität erreicht werden?}
\slides{3}{7}
Analyse: man hat schon etwas und schaut nach (Test: analytische Fehlersuche).\\
Konstruktion: es wird erst gebaut (im Vornherein gut Programmieren).
\slides{3}{9}
SW-Qualität -- erfordert Kosten und Zeit
\slides{3}{10}
\paragraph{Lösung:}
Durch gezielte Qualitätssicherung im 
\begin{itemize}
\item organisatorischen Bereich\\
(Vorgehen bei der Software-Entwicklung $\to$ Vorgehensmodelle)
\item im Rahmen der Anforderungsmodellierung
\item im konstruktiven Bereich\\
(Analyse, Entwurf, Implementierung $\to$ Muster, Schnittstellen, Werkzeuge…)
\item im analytischen Bereich (Test)
\end{itemize}

\chapter{Anforderungen}

\section{Die Rolle der Anforderungen des Kunden im Rahmen der Softwareentwicklung}
\begin{itemize}
\item Anforderungen sind Ausgangspunkt der Entwicklung, daraus resultiert ihre große Bedeutung (sowohl inhaltlich als auch zeitlich).
\item Die Anforderungen verbinden Kunden und Entwickler.
\item Die Anforderungen sind Maß der Dinge bei der Übergabe des Produktes.
\end{itemize}

\section{Was sind Anforderungen?}
\paragraph{Beispiel für Anforderungen}
Das SW-System „xy“ soll…
\begin{itemize}
\item auf verschiedenen Plattformen laufen (Achtung: was sind die konkreten Platformen?).
\item im Web-Browser laufen.
\item in verschiedenen Sprachen den Benutzer führen.
\item immer verfügbar sein (7/24).
\item Die Zeit zur Fehlerbehebung soll minimal sein.
\item eine grafische Benutzeroberfläche haben.
\end{itemize}
(sprich: soll etwas \emph{haben})\bigskip\\
MS-Word soll…
\begin{itemize}
\item es erlauben, die Zeichen zu formatieren (fett, kursiv, …).
\item es erlauben Text zu drucken.
\end{itemize}
(sprich: soll etwas \emph{tun})
\slides{4}{4}
\subsection{Funktionelle und nicht-funktionelle Anforderungen}
\slides{4}{5}
\slides{4}{6}
\begin{itemize}
\item funktionale Anforderungen:\\
Funktionserfüllung
\item nicht-funktionale Anforderungen
\begin{itemize}
\item Qualitätseigenschaften:\\
Benutzerfreundlichkeit\\
Effizienz\\
Zuverlässigkeit/Sicherheit\\
Portabilität\\
Kompatibilität\\
Erweiterbarkeit\\
Änderbarkeit
\item einschränkende Rahmenbedingung
\begin{itemize}
\item organisatorische Rahmenbedingungen
\item technisch/technologische Rahmenbedingungen
\item rechtliche Rahmenbedingungen
\end{itemize}
\end{itemize}
\end{itemize}
Also vielmehr:
\slides{4}{7}
Unterschied technologisch vs technisch (Bsp Datenbank)
\begin{itemize}
\item technologisch:\\
relationale, hierarchisch, …
\item technisch:\\
MySQL, Oracle, …
\end{itemize}
\subsubsection{Unterscheidung der Anfordernugstypen am Beispiel Bibliothek}
\slides{4}{9}
funktionale Anforderungen brauchen in jedem Fall ein \emph{Verb}.\\
Auslöser-Reaktions-Tabelle (ART) für (unabhängige) funktionale Anforderungen (Bsp. Bibliothek).
\begin{tabular}{L{.2} | L{.2} | L{.15} | L{.15} | L{.2}}
Ereignis & funktionale Anforderungen & Eingabe-Daten & Ausgabe-Daten &Bemerkung (Q,R)\\
\hline 
Person will sich in der Bibo anmelden & Benutzer anmelden & Anmeldewunsch & Benutzerausweis, alternativ: Absage & darf noch nicht angemeldet sein, Alter $\geq$ 18, Wohnort $\to$ Sachsen, …\\
\hline 
Person will im Katalog suchen & Buch suchen & Suchanfrage & Suchantwort & Antwortzeit $\leq $ 3 Sek, …\\
\hline 
… &&&&
\end{tabular}

\subsection{Definition Anforderung}\parskp
Eine Anforderung ist eine Beschaffenheit oder Fähigkeit, die von einem Benutzer zur Lösung eines Problems oder zur Erreichung eines Zieles benötigt wird.\\
Es gibt funktionale und nicht-funktionale Anforderungen.\\
Diese nicht-funktionalen Anforderungen sind genau genommen
\begin{itemize}
\item Qualitätsanforderungen oder
\item einschränkende Rahmenbedingungen\\
(technisch/technologische, organisatorische, rechtliche Rahmenbedingungen).
\end{itemize}
Problematische Synonyme sind: Leistungsmerkmale, feature

\subsection{Begriff feature}
\slides{5}{1}

\chapter{Risiken der Anforderungsanalyse}
Am Beispiel:
\slides{5}{4}
\begin{tabular}{L{.2} | L{.58} | L{0.22}}
Risiko & Vermeidung & Qualitätsmerkmal\\\hline
Missverständlichkeit\newline (Uneindeutigkeit) & Regeln einhalten\medskip\newline
Schaubild:\newline DKB AG $\overset{\text{Geld}}{\longrightarrow}$ Baustelle\medskip\newline
Rückfragen beim Kunden $\to$ Kommunikation (Validierung)\medskip\newline
Prototyp& eindeutig\\\hline
Anforderung ist nicht realisierbar & experimenteller Prototyp (bspw. Überprüfung der geforderten Antwortzeit) \medskip\newline
Abschätzung & realisierbar\\\hline
Anforderungen sind unvollständig & Validierung ($\to$ Kommunikation mit Kunden) \medskip\newline grafische Darstellung \medskip\newline Prototyp (Click Dummy) & vollständig\\\hline
falsch & Rückfragen $\to $ Validierung $\to$ Kommunikation mit Kunden \medskip\newline (grafische Darstellung) [möchte Kunde mit Grafiken umgehen?]& korrekt\\\hline
falsch priorisiert / zu viel Aufwand & Kommunikation mit Kunden & angemessen \\\hline
widersprüchlich & offenlegen von Abhängigkeiten $\to$ (direkte) Kommunikation mit dem Kunden & widerspruchsfrei\\\hline
zu umfangreich beschrieben & grafische Darstellungen & minimal
\end{tabular}\bigskip

Unterschied Verifizierung/Validierung (am Beispiel):\\
Verifizierung: „Baue ich das Haus richtig?“\\
Validierung: „Baue ich das richtige Haus?“

Also:
\section{Die Risiken}
Verletzung der Qualitätsmerkmale:
\begin{itemize}
\item Eindeutigkeit
\item Realisierbarkeit
\item Vollständigkeit
\item Korrektheit
\item Angemessenheit
\item Widerspruchsfreiheit
\item Minimal
\end{itemize}

\section{Die Vermeidung}
\begin{itemize}
\item bewusste Diskussion mit dem Kunden ($\to$ soziale Kompetenz)
\item klare, eindeutige Formulierung,
\item Verwendung eines Glossars
\item Ergänzung der Dokumente in natürlicher Sprache durch geeignete Modelle ($\to$ Dokumente mit grafischen Darstellungen)
\item Verwendung von Werkzeugen, die die Konsistenz unterstützen
\item  Einbeziehung von Prototypen (experimentelle Prototypen, funktionale Prototypen)
\end{itemize}
Wichtig: Die Kommunikation
\slides{5}{6}

\section{Die Analyse}
\slides{5}{8}
\begin{itemize}
\item Ziele:\\
Klare Formulierung des Problems, das durch Einsatz des SW-Systems gelöst werden soll.\\
„Auf welche Frage ist das zu entwickelnde SW-System die Antwort?“
\item Stakeholder:\\
Anwender,
Wissensträger,
Interessenvertreter,
Lobby, …
\item Kontext:\\
Wer/was aus dem Kontext interagiert über die Schnittstellen (Verbindungsstellen) mit dem System?\\
Anwender, Administrator, andere Systeme, …
\end{itemize}

\slides{5}{13}
\slides{5}{14}
\slides{5}{15}

\subsection{Der Anfang der Anforderungsanalyse}

Systemziele und Systemkontext sind die Basis für alle Anforderungen und damit auch für
das gesamte Projekt. Wichtig ist ein wertungsfreier Umgang mit Systemzielen und
Systemkontext. Ebenso wichtig ist es, zu Beginn alle am Projekt Beteiligten Personen mit
ihren Rollen und Interessen zu kennen.

\subsection{Ermittlung der Anforderung}

\begin{itemize}
\item Kreavitätstechniken (Brainstorming, Wechsel der Perspektive, …)
\item Befragungstechniken (Fragebogen, Interview, …)
\item artefaktbasierte Techniken (Eingabe-, Ausgabedokumente, $\to$ Wiederverwendung)
\item Audio‐, Videoaufzeichnungen
\item Anwendungsfallmodellierung, Essenzbildung (das wichtige heraus filtern)
\end{itemize}

\subsection{Zu berücksichtigende Informationsquellen}

Alle Stakeholder, also alle Beteiligten. 

Wichtig: Zu Beginn definieren, wer Stakeholder ist, damit klar ist, wer was zu sagen hat und wer nicht.

\chapter{Anforderungensanalyse}

\section*{Beschreibung ermittelter Anforderungen}
\begin{itemize}
\item textuelle $\to$ natürlich-sprachlich
\begin{itemize}
\item[$+$] Sprache allgemein bekannt
\item[$-$] Missverständlichkeit / Interpretierbarkeit
\item[$-$] Redundanz
\end{itemize}
\item graphisch $\to$ Modellierungs-Sprache
\begin{itemize}
\item[$+$] 
\item[$-$] „Sprache“ muss bekannt sein (UML, …)
\end{itemize}
\end{itemize}
Neutral für beide Seiten:
\begin{itemize}
\item[$\circ$] kann übersichtlicher/unübersichtlicher sein (je nach Strukturierung und was der Person mehr liegt: subjektiv)
\end{itemize}
\begin{itemize}
\item Satzschablonen (Chris Rupp)
\end{itemize}

\section{Graphische Beschreibung von funktionalen Anforderungen}
\begin{itemize}
\item strukturierte (prozedurale) Programmierung (SP)\\
$\to$ strukturierter Entwurf (SD)\\
$\to$ strukturierte Analyse (SA)\\
$\Rightarrow$ SA$\to$SD$\to$SP
\begin{itemize}
\item Funktionsdiagramm
\item Datenstrukturdiagramm
\item Datenflussdiagramm
\item ERM
\item Zustandsdiagramm
\end{itemize}
\item objektorientierte Programmierung (OOP)\\
$\to$ objektorientierter Entwurf (OOD)\\
$\to$ objektorientierte Analyse (OOA)\\
$\Rightarrow$ UML (OOA$\to$OOD$\to$OOP)
\begin{itemize}
\item Klassendiagramm
\item Aktivitätsdiagramm
\item Zustandsdiagramm
\item Anwendungsfalldiagramm
\item[] $\vdots$
\end{itemize}
\end{itemize}
UML $\to$ offener Standard
\begin{itemize}[label=$\to$]
\item in Entwicklung
\item Stereotypen können vom Entwickler definiert und benutzt werden
\end{itemize}

\section{Struktur-Diagramm / UML}
Ein Strukturdiagramm hat:
\begin{itemize}
\item Knoten
\item Kanten
\item Topologie (Netz, Baum, Hierarchie, …)
\item Semantik (je nach Diagrammtyp)
\end{itemize}
UML kennt:
\begin{itemize}
\item Strukturdiagramme (Aufbaustruktur $\to$ statische Eigenschaften)
\begin{itemize}
\item Klassendiagramm
\item Paketdiagramm
\item Verteilungsdiagramm
\item Objektdiagramm
\item Komponentendiagramm
\item Kompositionsstrukturdiagramm
\end{itemize}
\item Verhaltensdiagramme (Ablaufstruktur $\to$ dynamische Eigenschaften)
\begin{itemize}
\item Anwendungsfalldiagramm
\item Aktivitätsdiagramm
\item Zustandsdiagramm
\item Sequenzdiagramm
\item Kommunkationsdiagramm
\item Interaktionsübersichtsdiagramm
\item Zeitverlaufsdiagramm
\end{itemize}
\end{itemize}

\subsection{Das Anwendungsfalldiagramm}
\subsubsection{Semantik}
Das AWF-Diagramm stellt die funktionalen Anforderungen aus der Sicht der Anwender dar.\\
Die funktionalen Anforderungen werden zu den Beteiligten aus dem Kontext in Beziehung gesetzt.\\
Die Beziehung zwischen dem (externen) Anwender und dem AWF ist eine Kommunikationsbeziehung.
\subsubsection{Knoten}
\begin{itemize}
\item \begin{tikzpicture} [scale=.3]
\draw  (0,0) ellipse (2 and 1);
\end{tikzpicture} Anwendungsfälle
\item \begin{tikzpicture} [scale =.15]
\draw  (-3,4) ellipse (1 and 1);
\draw (-3,3) -- (-3,0) -- (-4,-3);
\draw (-2,-3) -- (-3,0);
\draw (-3,2) -- (-5,1);
\draw (-3,2) -- (-1,1);
\end{tikzpicture} Akteur
\end{itemize}
\subsubsection{Kanten}
\begin{itemize}
\item $\longleftrightarrow$ Kommunikationsbeziehung zwischen AWF und Akteur
\item \begin{tikzpicture} [scale=.2]
\fill (-2,-1) -- (-1,-2) -- (0,-1) -- cycle;
\draw (-1,0) -- (-1,-1);
\end{tikzpicture} Generalisierung / Spezialisierung zwischen Akteuren
\item $\longrightarrow$ <<enthält>> (include), <<erweitert>> (extend) $\to$ zwischen AWF\\
Tipp Pfeilrichtung: Durch aktiven Satz verdeutlichen (ausleihen enthält prüfen wird zu: prüfen $\overset{\text{<<enthält>>}}{\longleftarrow}$ ausleihen)
\end{itemize}
\subsubsection{Topologie}
Netzförmig

\subsubsection{Begriffe}
AWF $\corr$ Prozess, Szenario, d.h.: Ein AWF kapselt eine Menge von Aktionen, die sequentiell nacheinander ablaufen oder zyklisch oder bedingungsabhängig gesteuert werden.
\begin{itemize}
\item Der AWF wird ausgelöst durch Ereignis:
\begin{itemize}[label=$\to$]
\item datengetriebenes Ereignis (bspw. Anmeldewunsch $\to$ Benutzer anmelden)
\item zeitgesteuertes Ereignis
\end{itemize}
\item Der AWF führt in der Regel zu einem von außen sichtbaren Ereignis für den Anwender (bspw. Benutzerausweis als Ergebnis von „Benutzer anmelden“).
\end{itemize}
Konzept: $\overset{\text{E}}{\longrightarrow}\boxed{V}\overset{\text{A}}{\longrightarrow}$ (Eingabe, Verarbeitung, Ausgabe) \bigskip\\
Akteur $\corr$ Ein \emph{außerhalb des Softwaresystems} existierendes Objekt, das mit dem SW-System \emph{interagiert}.
\begin{itemize}
\item ist rollenorientiert.
\item ist aktiv oder passiv.\\
Aktive Rollen:
\begin{itemize}
\item Anwender
\item zeitliches Ereignis
\item externes System
\end{itemize}
Passive Rolle:
\begin{itemize}
\item tut nichts, wird aber zur Abarbeitung des AWF'es benötigt (bspw.: Kurstabelle für eine Wechselstube / Aktien, Fahrplan, …) $\Rightarrow$ vorhandene Daten
\end{itemize}
\end{itemize}

\subsection{Aktivitätsdiagramm}
Für Anwendungsfälle, die Abhängigkeiten erschaffen (voneinander):
\begin{itemize}
\item Bibliothek nutzen und verwalten (Gesamtfunktion)
\begin{itemize}
\item Literatur suchen
\item Benutzerdaten verwalten
\begin{itemize}
\item Benutzer anmelden
\item Benutzer abmelden
\item Benutzerdaten ändern
\item Benutzerausweis verlängern
\end{itemize}
\item Ausleihdaten verwalten (intern)
\item Mahnungen verwalten
\item[] $\vdots$
\end{itemize}
\end{itemize}
$\Rightarrow$ diese Anwendungsfälle sind alle unabhängig voneinander!\\
Abhängigkeiten entstehen, wenn man Anwendungsfälle weiter verfeinert. Beispielsweise beim Verfeinerung von „Benutzer anmelden“: 

Der Fall „Anmeldewunsch prüfen“ wäre abhängig von „Anmeldewunsch annehmen“ usw.\\
Ein Anwendungsfall ist dann nicht mehr abstrakt, wenn es sich nicht mehr verfeinern lässt, ohne Abhängigkeiten zu erzeugen!

\subsubsection{Semantik}
Ein Aktivitätsdiagramm beschreibt einen Algorithmus (einen Algoritmus, den der Anwendungsfall kapselt). D.h. das Aktivitätsdiagramm stellt dar, welche Aktionen aufeinander folgen, zyklisch oder bedingungsabhängig gesteuert sind Sequenz, Iteration, Alternative).\\
Besonderheit: \\
Aktionen \emph{können} definierten Verantwortungsbereichen zugeordnet werden ($\to$ Swimlane)\\
entwickelt aus:\\
PAP, Petrinetze, Datenflussdiagramme

\subsubsection{Knoten}
\begin{itemize}
\item 1 Anfangs-, eventuell mehrere Endknoten
\item Aktionen \begin{tikzpicture} [scale=.3]
\draw  (0,0) ellipse (2 and 1);
\end{tikzpicture}
\item Entscheidungsknoten \begin{tikzpicture}[scale=0.2]
\draw (-1,2) -- (-2,1) -- (-1,0) -- (0,1) -- cycle;
\draw [-latex] (-1,4) -- (-1,2);
\draw [-latex] (0,1) -- (2,1);
\draw [-latex] (-2,1) -- (-4,1);
\end{tikzpicture}
\item Synchronisationsknoten \begin{tikzpicture}[scale=0.2]
\draw (-7,-2) -- (-1,-2);
\draw [-latex] (-4,-2) -- (-4,-4);
\draw [-latex] (-6,0) -- (-6,-2);
\draw [-latex] (-2,0) -- (-2,-2);
\draw (1,-2) -- (7,-2);
\draw [-latex] (4,0) -- (4,-2);
\draw [-latex] (2,-2) -- (2,-4);
\draw [-latex] (6,-2) -- (6,-4);
\end{tikzpicture}
(AND, OR, XOR)
\end{itemize}

\subsubsection{Kanten}
\begin{itemize}
\item Transition
\item Objektfluss \begin{tikzpicture}[scale=0.2]
\draw  (-7,3) rectangle (-3,2);
\draw [-latex] (-5,5) -- (-5,3);
\draw  [-latex] (-5,2) -- (-5,0);
\end{tikzpicture}
\end{itemize}

\subsubsection{Topologie}
netzförmig

\subsection{Das Zustands-(übergangs-)diagramm}
\subsubsection{Semantik}
Das Zustandsdiagramm stellt die einzelnen Zustände dar, die eine Betrachtungseinheit haben kann, inklusive der Zustandsübergange.\\
Das heißt das Zustandsdiagramm zeigt, wann ein \emph{Zustand} in einen anderen \emph{wechselt} (nach welchem \emph{Ereignis}?) und welche nach außen sichtbare Reaktion dabei erfolgt (welche \emph{Aktion} wird dabei ausgeführt?)\\
Der Zustandswechsel kann \emph{bedingungsabhängig} sein.\\
Zu einem definierten Zeitpunkt befindet sich die Betrachtungseinheit in einem definierten Zustand $\to$ Modellierung von Automaten ($\to$ Steuersysteme)

\begin{tikzpicture}[-latex,shorten >= .3em,shorten <= .3em,auto,node distance=10em]
\node[state] (z0) {$Z_1$};
\node[state] (z1) [right of=z0] {$Z_2$};
\path (z0) edge [bend left = 20] node [below]{$E[B]/A$} (z1);
\end{tikzpicture}

\subsubsection{Knoten}
\begin{itemize}
	\item 1 Startknoten, einen oder mehrere Endknoten, Zwischen-Knoten
	\item Entscheidungsknoten
	\item Terminator
	\item für paralleles Verhalten: Regionen mit Gabelung/Zusammenführung
	\item[] $\vdots$
\end{itemize}

\subsubsection{Kanten}
Transition mit Ereignis, eventuell Bedingung und Aktion.

\subsubsection{Topologie}
netzförmig

\subsection{Das Klassendiagramm}
\subsubsection{Semantik} Das KD stellt die \emph{Klassen} ($\corr$ Bauanleitung für Objekte) und ihre \emph{statischen} Beziehungen dar. 
\subsubsection{Knoten}
\begin{itemize}
	\item konkrete Klassen (instanziierbar)
	\item abstrakte Klassen (nicht instanziierbar)
	\item generische Klassen
	\item Interface
\end{itemize}
\subsubsection{Kanten}
\begin{itemize}
	\item Assoziation ($\to$ Operationsaufruf)
	\item Generalsierung/Spezialisierung („Vererbung“)\\
	Einordnung von Typen
	\item Aggregation (Teile-Ganze-Beziehung)\\
	hohles Viereck am anderen Ende des Pfeils\\
	Das Teil kann weiter existieren, wenn es das Ganze nicht mehr gibt.\\
	Bsp: \fbox{Belegarbeitsgruppe} $\diamond\!\! \to$ \fbox{Gruppenmitglied} (Gruppenmitglieder existieren noch[als Person], wenn sich Gruppe auflöst)
	\item Komposition (strenge Teile-Ganze-Beziehung)\\
	gefülltes Viereck am anderen Ende des Pfeils\\
	Das Teil kann nicht mehr existieren, wenn es das Ganze nicht mehr gibt.
\end{itemize}

\subsubsection{Topologie}
netzförmig mit eingelagerten Hierarchien

\subsubsection{Beispiel}
Datei-System
\paragraph{Knoten} $\to$ Klassenkandidaten:
\begin{itemize}
	\item Datei
	\item Ordner
\end{itemize}
\begin{tikzpicture}[scale=.5]
\draw  (-4,-2) rectangle (0,-4) node[pos=.5]{Datei};
\draw  (2,-2) rectangle (6,-4) node[pos=.5]{Ordner};
\draw  (-1,4) rectangle (3,2) node[pos=.5]{Knoten};
\draw [blue] (-2,-2) -- (-2,0) -- (1,0) -- (1,1);
\draw [blue] (4,-2) -- (4,0) -- (1,0);
\draw [blue] (1,2) -- (0,1) -- (2,1) -- (2,1) -- cycle;
\draw[ red, open diamond - latex] (6,-3) -- (8,-3) -- (8,3) -- (3,3);
\draw  (-10,-2) rectangle (-6,-4) node[pos=.5]{Verweis};
\draw [-latex, green] (-10,-3) -- (-11,-3) -- (-11,3) -- (-1,3);
\draw [blue] (-8,-2) -- (-8,0) -- (-2,0);
\draw [orange]  (-5,5) rectangle (9,-5) node[below left]{Entwurfsmuster: Kompositum (Composite)};
\end{tikzpicture}

\subsubsection{Perspektiven}
Drei Perspektiven eines Klassendiagramms:
\begin{enumerate}
\item \emph{Analyse}-Klassendiagramm\\
Perspektive des Kunden:\\
Sicht auf Klasssen\emph{kandidaten} aus dem Anwendungskontext

„was muss gemacht werden?“\\
OOA
\item \emph{Entwurfs}-Klassendiagramm\\
Perspektive des Entwerfers:\\
Sicht auf die \emph{Schnittstellen} der Klassen und ihre Beziehungen $\to$ alle \emph{öffentlichen} Operationen\\
Grobentwurf (Systemarchitektur) $\to$ Feinentwurf (Komponenten-Entwurf)

„wie muss das aus der Analyse gemacht werden $\Rightarrow$ wer macht was?“\\
OOD
\item \emph{Implementations}-Klassendiagramm\\
Perspektive des Entwicklers (Programmierers):\\
Sicht auf \emph{alle} Details einer Klasse\\
(Attribute, Operationen [Signaturen: \lstinline$... funktname (...)$; auch: Prototyp, Funktionskopf])

„wie wird der Entwurf tatsächlich umgesetzt?“\\
OOP
\end{enumerate}

\section{Verwendungen von UML-Diagrammen}
Klassendiagramm: statische Struktur des Softwaresystems (Perspektiven: erste Analyse / Blick auf Schnittstellen / Implementation)\\
Anwendungsfalldiagramm: Beschreibung der funktionalen Anforderungen (Überblick)\\
Aktivitätsdiagramm: Beschreibung eines Anwendungsfalls (Details)\\
Zustandsdiagramm: Bei welchem Ereignis ändert das Objekt seinen Zustand (und was bekommt die Außenwelt davon mit). Diese Zustände beschreiben die Werte eines Status-Variable einer Klasse.
% Folie 1

\section{Essentielle Funktionen}
Was ist eine essentielle Funktion?\\
\begin{tabular}{L{.2} | L{.2} | L{.15} | L{.15} | L{.25}}
Ereignis & funktionale Anforderungen & Eingabe-Daten & Ausgabe-Daten &Bemerkung (Q,R)\\
\hline\hline
beliebige Person will im Katalog suchen & im Katalog suchen & Suchanfrage & Suchantwort & --\\\hline
Person will sich anmelden & Benutzer anmelden & Anmeldewunsch & Benutzerausweis / Absage & beim wiederholten Anmelden $\to$ Absage\\\hline
Benutzer will sich abmelden & Benutzer abmelden & … & … & …\\\hline
Benutzer will Daten ändern & Benutzerdaten ändern & … & … & …\\\hline
Benutzer will Gültigkeit verlängern & Benutzerausweis verlängern & … & … & …
\end{tabular}\\
Benutzerdaten verwalten besteht aus Benutzer anmelden/abmelden, Benutzerdaten ändern und Benutzerausweis verlängern.\\
Benutzer anmelden $\to$ essentielle Funktion\\
Benutzerdaten verwalten $\to$ essentielle \emph{Gruppe}\\\bigskip

Eine essentielle Funktion ist:
\begin{itemize}
\item kleinste, von anderen essentielle Funktion \emph{unabhängige} Funktion
\item hat genau einen \emph{Auslöser}
\begin{itemize}
\item datengetrieben ($\to$ Eingabedaten)
\item zeitlich
\end{itemize}
\item hat kein, eine oder mehrere Reaktionen ($\to$ Ausgabedaten)
\item wiederholbar, ohne dass dazwischen eine essentielle Funktion ausgeführt werden muss
\end{itemize}

\section{Satzschablonen}
\subsection{Beschreibung von Anforderungen an einem SW-System}
\begin{itemize}
\item textlich
\item Satzschablonen (nach Chris Rupp)
\item graphisch (z.B. UML)
\begin{itemize}
\item AWF-Diagramm
\item Aktivitäts-Diagramm
\item Zustandsdiagramm
\item[$\Rightarrow$] Klassen-Diagramm (Analyse-Klassen-Diagramm)
\end{itemize}
\end{itemize}

\subsection{Regel der Satzschablonen}
\slides{11}{1}
\slides{11}{2}

\subsection{Bilden von Satzschablonen}

\subsubsection{Charakter der Aktivität}
\slides{11}{3}

\subsubsection{Rechtliche Verbindlichkeiten}
\slides{11}{4}
\slides{11}{5}
\slides{11}{6}

\subsubsection{Objekt einbeziehen}
\slides{11}{7}

\subsubsection{Bedingungsabhängikeiten einbeziehen}
\slides{11}{8}



\chapter{Lasten und Pflichtenheft}

\slides{11a}{1}

Unterschied Lasten $\leftrightarrow$ Pflichtenheft:
\begin{itemize}
\item Das Lastenheft (siehe DIN 69905 1997)\\
„Das Lastenheft enthält eine Definition der Systemvision eine Beschreibung der wesentlichen Systemziele (Funktionen und Qualitäten) und benennt wichtige Kontextaspekte (z.B. Rahmenbedingungen) der vier Kontextfacetten sowie ihre Beziehung zur Vision und zu den definierten Systemzielen.“
\item Das Pflichtenheft (siehe DIN 69905 1997)\\
„Das Pflichtenheft detailliert die im Lastenheft beschriebene Vision und die Systemziele (abstrakte Funktionen und Qualitäten) sowie ggf. im Lastenheft definierte Rahmenbedingungen \emph{im Hinblick} auf die angestrebte technische Umsetzung (Realisierung) des Systems.“
\end{itemize}
bzw. kurz:
\begin{itemize}
\item Das Lastenheft beschreibt die System-\emph{Vision} des Auftraggebers.
\item Das Pflichtenheft detailliert diese Vision aus der Sicht des Auftragnehmers.\\
Es ist eine mögliche Realisierungsvariante.
\end{itemize}

\section{Pflichtenheft}

\begin{itemize}
\item Adressiert an:
\begin{enumerate}
\item \emph{Auftragnehmer}:\\
Auftraggeber übergibt Auftrag (beschrieben durch Pflichtenheft) an Auftragnehmer.\\
Auftragnehmer übergibt SW-System an Auftraggeber.
\item \emph{Dritte / Auftraggeber / potenzielle Auftragnehmer}:\\
Auftraggeber übergibt Auftrag zum Erstellen des Pflichtenheftes an Dritten.\\
Dritter übergibt Pflichtenheft an Auftraggeber.\\
Auftraggeber verteilt Pflichtenheft an potentielle Auftragnehmer, die sich für diesen Auftrag bewerben. Von denen wird einer ausgewählt.
\end{enumerate}
\item Charakter: 
Vertragscharakter
\end{itemize}

\subsection{Pflichtenheft muss enthalten}
Alle Anforderungen an das zu entwickelnde SW‐(Teil‐)System, die (zu dieser Zeit) erkennbar sind.\\
D.h. funktionale und Qualitätsanforderungen ebenso wie einschränkende Rahmenbedingungen (organisatorische, rechtliche und technische/technologische).\\
Da es in der Regel zwei Adressaten (AG/AN) und quasi Vertragscharakter hat,
muss es analog zur Anforderungsanalyse folgende Eigenschaften haben:
\begin{itemize}
\item verständlich sein für den Auftraggeber und hinreichend präzise für den
Auftragnehmer,
\item korrekt, vollständig, eindeutig, widerspruchsfrei, minimal, erweiterbar sein,
\item realisierbar, nachvollziehbar und hinsichtlich der Erfüllung überprüfbar sein. 
\end{itemize}

\subsection{Aufbau eines Pflichtenhefts}
\begin{enumerate}
\item Ausgangssituation und Zielsetzung
\item Systemeinsatz und Umgebung
\item Benutzerschnittstellen
\item Funktionale Anforderungen
\item Qualitätsanforderungen
\item Rahmenbedingungen (techn./technologisch, org., rechtlich)
\item Fehlertoleranzmaßnahmen
\item Anforderung an die Dokumentation
\item Abnahmekriterien
\item[] Glossar (Begriffslexikon)
\item[] Index
\item[] Anhang
\end{enumerate}

% Lastenheft?

\chapter{Vorgehensmodelle der SW-Entwicklung}

\section{SW-Lebenszyklus}
\slides{12}{8}
(auch „Wasserfallmodell“ genannt)
\subsection{SW-Lebenszyklus mit Rückkopplung}
\slides{12}{9}

\section{V-Modell}
\slides{12}{11}
\slides{12}{12}
\subsection{Interaktion der Submodelle}
\slides{12}{13}
\subsection{Das Submodell SWE}
\slides{12}{14}
\subsection{Rollenzuordnung}
\slides{12}{15}
\slides{12}{16}

\section{Spiralmodell nach Boehm}
\slides{12}{18}
Jeder Quadrant wird pro Phase nur einmalig besucht!

\section{Iterativ-inkrementelles Vorgehen}
\slides{12}{21}

\subsection{Rational Unified Process (RUP)}
Unified Process $\to$ Rational Unified Process (RUP) (Booch, Jakobsen, Rumbaugh)
\slides{12}{22}
\slides{12}{23}

\subsection{Iterativ-inkrementelles Vorgehen}
\slides{12}{24}

\section{Vergleich der Modelle}
\subsection{SW-Lebenszyklus}
\paragraph{Wesen}
\begin{itemize}
\item SW-Entwicklungsprozess ist zerlegt in sachliche Phasen, die aufeinander folgen ($\to$ sachliche + zeitliche Gliederung).
\item Das Ergebnis einer Phase ist Ausgangspunkt der folgenden Phase.
\end{itemize}

\paragraph{Vorteil}
\begin{itemize}
\item Einfache Projektverwaltung 
\end{itemize}

\paragraph{Nachteil}
\begin{itemize}
\item \emph{keine} Rückkopplung
\item bzw. mit Rückkopplung: Im Fehlerfall wird nur um eine Stufe zurück gegangen.
\end{itemize}

\paragraph{Rahmenbedingung}
\begin{itemize}
\item Alle Anforderungen stehen zu Beginn fest.
\end{itemize}

\paragraph{Rahmenbedingung} siehe SW-Lebenszyklus

\subsection{V-Modell}
\paragraph{Wesen} 
\begin{itemize}
\item Standard im öffentlichen Bereich
\item 4 Submodelle (QS, SWE, KM, PM)
\item Submodell SWE betrachtet den gesamten Geschäftsprozess (System-/DV-/Software-Analyse zur Implementation bis zur Integration und wieder zurück mit jeweils Rückkopplung zur Analyse)
\end{itemize}

\paragraph{Vorteil}
\begin{itemize}
\item Einbeziehung der QS, KM, PM 
\end{itemize}

\paragraph{Nachteil}
\begin{itemize}
\item Großer Verwaltungsaufwand. 
\end{itemize}

\paragraph{Rahmenbedingung}
\begin{itemize}
\item Alle Anforderungen stehen zu Beginn fest.
\end{itemize}

\subsection{Spiralmodell}
\paragraph{Wesen} 
\begin{itemize}
\item klare Zielbestimmung
\item Suche nach Lösungs\emph{alternativen}
\item Evaluierung der Lösungsalternativen auf der Basis der Risikoabschätzung $\to $ Risikominimierung
\end{itemize}

\paragraph{Vorteil}
\begin{itemize}
\item Einbeziehung der alternativen
\item Risikobetrachtung
\end{itemize}

\paragraph{Nachteil}
\begin{itemize}
\item fehlende Rückkopplungen
\end{itemize}

\paragraph{Rahmenbedingung}
\begin{itemize}
\item Alle Anforderungen stehen zu Beginn fest.
\end{itemize}

\subsection{Iterativ-inkrementelles Vorgehen}
\paragraph{Wesen} 
\begin{itemize}
\item Gesamtfunktionalität wird in Teilfunktionalitäten aufgeteilt (Inkremente), die iterative entwickelt werden\\
\item[]$\to$ evolutionärer Prototyp
\end{itemize}

\paragraph{Vorteil}
\begin{itemize}
\item Komplexitätsbeherrschung durch „kleine Schritte“
\end{itemize}

\paragraph{Nachteil}
\begin{itemize}
\item hoher Verwaltungsaufwand
\end{itemize}

\paragraph{Rahmenbedingung}
\begin{itemize}
\item Anforderungen können sich in geringem Maß ändern
\item Es müssen nicht alle Anforderungen zu Beginn bekannt sein
\end{itemize}

\chapter{Agile Softwareentwicklung}
Sich ändernde Anforderungen des Kunden gehören zum Projekt. D.h. Wandel ist integraler Bestandteil des Projektes.

\section{Agilität}
„Kleine Schritte führen zum Ziel.“
\begin{itemize}
\item Stück für Stück implementieren
\item immer wider überprüfen
\item immer miteinander reden
\item einfache Lösungen suchen und implementieren
\item wenn nötig korrigieren
\end{itemize}
\subsection{Korrektur}
Korrigiert wird: der bisherige Aufbau des Systems\\
Also:\\
Wechsel von \emph{architektur-zentriert} $\to$ \emph{code-zentriert}\\
Achtung: es ist nicht gemeint, dass nur noch gecodet wird.

\subsection{Bedeutung}
\begin{itemize}
\item Akzeptanz von Wandel
\item Forderung von Wandel, wenn es sinnvoll erscheint
\end{itemize}
$\Rightarrow$ SW-Entwicklungsteam muss gewandt sein\\
nötig ist:
\begin{itemize}
\item umfangreiches theoretisches Wisen
\item praktische Erfahrung
\item Bereitschaft zur Überarbeitung und Änderung
\end{itemize}


\subsection{Manifest}
Es wird unterscheiden zwischen wichtigem und wichtigerem:\\
\begin{tabular}{c c}
wichtig\emph{er} & wichtig\\
Individuen und Interaktion & Prozesse und Werkzeuge\\
funktionierende Software & umfangreiche Dokumente\\
Zusammenarbeit mit Kunden & Vertragsverhandlung\\
auf Änderungen reagieren & einem Plan folgen
\end{tabular}\\
Achtung: wichtiges ist nicht unwichtig, nur weniger wichtig im Vergleich zum jeweiligem wichtigerem!

\subsection{Beispiele}
XP: extremes Programmieren\\
SCRUM

\section{Extremes Programmieren}
\slides{13}{9}

\subsection{4 Grundwerte}
\slides{13}{10}

\subsection{Praktiken}
\slides{13}{11}

\subsection{Zusammenfassung}
\slides{13}{12}

\subsection{Chancen}
\slides{13}{13}

\section{SCRUM}
\slides{13}{14}
\slides{13}{15}
\slides{13}{16}

\chapter{Analyse und Test}
\section{Tests}
Es kann bspw. getestet werden auf:
\begin{itemize}
\item Geschwindigkeit (Antwortzeit)
\item Was mit einem Input als Output raus kommt. Bspw. bei:
\begin{itemize}
\item Funktion (bei der Implementierung $\to$ Whiteboxtest)
\item Klassen (\emph{Komponententest})
\item Zusammenarbeit zwischen Klassen/Komponenten (\emph{Integrationstest}, man testet Schnittstellen)
\item ganzes System (\emph{Systemtest} $\to$ Blackboxtest)\\
Perspektive: des Kunden
\end{itemize}
\end{itemize}

\section{Systemtest}
\slides{15}{6}
$\Rightarrow$ Systematischer Test aus der Perspektive des Kunden\\
Daten die zu testen sind:
\begin{itemize}
\item kritische Daten (bspw. Division durch 0)
\item Grenzdaten (bspw. 18 bei Zulassung ab 18)
\end{itemize}

\subsection{Testdaten, Testfall und Rahmenbedingungen}
\slides{15}{7}

\section{Zusammenhang zwischen Anforderungsanalyse und Test eines SW-Systems}
\begin{itemize}
\item Die funktionalen Anforderungen (konkrete Anwendungsfälle, insbesondere die essenziellen Funktionen) sind wichtige \emph{Testfälle} im Kontext des Systemtestes.
\item Die Auslöser/Reaktionen der essenziellen Funktionen (Ein- und Ausgabedaten zu den konkreten Anwendungsfällen) sind wichtige \emph{Testdaten} im Kontext des Systemtestes.
\item Die Beschreibung der Anwendungsfälle (textlich, Aktivitätsdiagramm, Zustandsdiagramm, Satzschablonen) können wichtige \emph{Rahmenbedingungen} für die jeweiligen Testfälle enthalten.
\end{itemize}






\chapter{Konfigurationsverwaltung}

\section{Der Sinn von Konfigurationsverwaltung}
Die Konfigurationsverwaltung ist eine Rolle oder Organisationseinheit im Kontext des SW-Ent\-wick\-lungs\-prozesses, die die SW-Einheiten
\begin{itemize}
\item identifiziert,
\item bei Bedarf bereitstellt
\item ihre Änderungen überwacht und dokumentiert.
\end{itemize}
Dazu gehört auch die Rekonstruktion älterer SW-Einheiten und Konfigurationen.\\
D.h. ein Konfigurationsverwaltungssystem ermöglicht das effiziente Bereitstellen definierter
Konfigurationen eines SW-Systems abhängig von Varianten und Versionen.\\
Das Konfigurationsmanagement ist demzufolge eine Methode für die Organisation der täglichen
Arbeit. ($\to$ organisatorische Qualitätssicherung)

\section{Beziehung zwischen Konfigurations-, Varianten- und Versionsverwaltung}
Versions- und Variantenverwaltung sind Bestandteile der Konfigurationsverwaltung.

\section{Begriffe}
\begin{itemize}
\item \emph{Software-Einheit}:\\
atomar im Sinne ihrer Verwaltung, d.h. sie kann unabhängig von anderen SW-Einheiten bearbeitet/gespeichert/ausgetauscht werden.\\
Änderung einer SW-Einheit führt zu einer neuen \emph{Version}.
\begin{itemize}[label=$\rightarrow$]
\item d.h. eine Version hat (in der Regel) einen Vorgänger und einen Nachfolger.
\item d.h. Versionen stehen in zeitlicher Ordnung (Chronik).
\end{itemize}
Beachte Unterschied zwischen \emph{Revision}: SW-Einheit wird \emph{komplett} ersetzt (nicht nur zu Teilen
\item \emph{Variante}:\\
existiert nicht zeitlich hintereinander, sondern nebeneinander (d.h. zeitgleich)
\item \emph{Konfiguration}:\\
eine Menge von SW-Einheiten, die für einen definierten Zweck zusammengestellt ist und diese SW-Einheiten passen auch zueinander (= Auswahlverfahren).
\item \emph{Baseline}:\\
Konfiguration, die stabil ist (zusammengestellt und geprüft).
\end{itemize}

\section{Aufgaben der Konfigurationsverwaltung}
\begin{itemize}
\item SW-Einheiten identifizieren
\item SW-Einheiten bereit stellen:
\begin{itemize}
\item zum Verändern
\item zum Integrieren
\end{itemize}
\item Änderungen von SW-Einheiten überwachen und verwalten
\item Rekonstruktion älterer SW-Einheiten
\end{itemize}
$\Rightarrow$ d.h. Versions- und Variantenverwaltung ist Bestandteil der Konfigurationsverwaltung.\\
Wie werden dies Aufgaben realisiert?
\begin{itemize}
\item Welche Arbeitsorganisation?
\item Wie wird diese Arbeitsorganisation technisch unterstützt (Subversion, Git, …)? $\to$ Repository mit geeigneter Speichertechnik
\end{itemize}

\subsection{Arbeitsorganisation}
$\to$ Regeln
\begin{enumerate}
\item Die Entwickler \emph{teilen} sich den Quellcode.
\item Alle Entwickler arbeiten in der gleichen \emph{Entwicklerumgebung}.
\item Die Konnfigurationsverwaltung hat das Monopol bei der Bereitstellung von SW-Systemen.\\
Damit wird vermieden, dass 
\begin{itemize}
\item unbemerkt Varianten entstehen
\item unbemerkt Änderungen vorgenommen werden
\item jemand direkten Zugriff auf die Dateien hat
\end{itemize}
\item SW-Einheit wird (als Arbeits-zwischen-Ergebnis) zyklisch verwaltet:
\begin{itemize}
\item abholen
\item ändern
\item abliefern und bekanntmachen $\to$ Commit
\end{itemize}
\item Veraltete Versionen werden archiviert
\item Verzweigungen werden als Varianten verwaltet
\item SW-Systeme, die an Kunden ausgeliefert werden, werden mit dem Konfigurationsmanagementsystem zusammengestellt und präzise dokumentiert. Verwendet werden dabei nur geprüfte und freigegebene SW-Einheiten.
\end{enumerate}
Werkzeug mit Repository
\begin{itemize}
\item zentrale Versionsverwaltung
\item dezentrale Versionsverwaltung
\end{itemize}
\subsubsection{Zentrale Versionsverwaltung}
\begin{itemize}
\item Entwickler und Reposiory-Umgebung (in der Regel auf einem Server) sind getrennt.
\item Jeder Entwickler arbeitet auf einer Kopie.
\item[$\to$] Subversion
\end{itemize}
\subsubsection{Dezentrale Versionsverwaltung}
\begin{itemize}
\item Entwickler- und Repository-Umgebung sind nicht getrennt.
\item Jeder Entwickler verfügt über ein eigenes Repository (Klon). Aus diesem Repository arbeitet er.
\item[$\to$] Git
\end{itemize}






%\newpage

%\printbibliography
 
\end{document}