% Header aus der Vorlage
\input{../LaTeX_master/LaTeX_master_HTW}

\bibliography{../Literatur/HTW_Literatur.bib}

% Definition von Titel, Autor usw.
\DTitel{Programmierung 1}
\DUntertitel{Übungsskript}
\DAutor{Falk Jonatan Strube}
\DNotiz{Übung von Prof. Dr.-Ing. Beck}

\begin{document}

\pagenumbering{Roman}

\maketitle
\newpage
\tableofcontents
\newpage

\pagenumbering{arabic}

\section{Eingebaute Datentypen}

\subsection{Zahlentypen}
Zahl: $\underset{8\cdot 10^0}{1} \; \underset{0 \cdot 10^1}{0} \;\underset{1\cdot 10^2}{8}$\\
$\Rightarrow$ 10er-System (Decimal)\\
Zahl: $0110\underset{\leftarrow usw.}{1}\;\underset{1\cdot 2^2}{0}\;\underset{0\cdot 2^1}{0}\;\underset{0\cdot 2^0}{0} = 0 + 0 + 4+8+0+32+64+0 =108$\\
$\Rightarrow$ 2er-System (Binär)\\
Zahl: $\underset{1}{001}|\underset{5}{101}|\underset{4}{100}=108$\\
$\Rightarrow$ 8er-System (Octal)\\
Zahl: $\underset{6}{0110}|\underset{C}{1100}=108$\\
$\Rightarrow$ 16er-System (Hexa)\\
Unterschied: $108_{/10}$, $01101100_{/2}$, $154_{/8}$ (in C gekennzeichnet durch $0154\rightarrow$ Octalzahl) und $6C_{/16}$ (in C gekennzeichnet durch $0x6C$)

\paragraph{Veranschaulichung}
\begin{align*}
108:2&=54 &R \emptyset\\
65:2 &= 27 &R \emptyset\\
27:2&= 13 &R 1\\
13:2 &= 6 &R 1\\
6:2 &=3 &R \emptyset\\
3:2 &= 1 &R 1\\
1:2&= 0 &R 1\\
&\Rightarrow 1101100 \text{ von unten nach oben gelesen}&
\end{align*}

\begin{align*}
108:8 &= 13 &R4\\
13:8 &= 1 &R5\\
1:8 &= 0 &R1\\
&\Rightarrow 154&
\end{align*}

\begin{align*}
108: 16 &= 6 &R12 = RC\\
6:16 &= 0 &R6\\
&\Rightarrow 6C&
\end{align*}

Beispielzahl 0x12AB\medskip\\
Speicherblock:\\
\begin{tabular}{|l|l|l|l|}
\hline
1&2&A&B\\
\hline
\end{tabular} big-endian\\
\begin{tabular}{|l|l|l|l|}
\hline
B&A&1&2\\
\hline
\end{tabular}\\
\begin{tabular}{|l|l|l|l|}
\hline
A&B&1&2\\
\hline
\end{tabular} little-endian\\
Letzte Version ist die, die heutzutage meistens (Intel) verwendet wird: Das niederwertigste Byte liegt auf der niedrigsten Adresse.

\paragraph{2er Komplement}
positive Zahl: $\boxed{0}110 \: 1100$\\
Negation: $1001\: 0011$\\
$+1$\\
Komplement: $1001 \: 0100 = -108 = 0x94$\\
\begin{tabular}{r | l l l l l l l l l}
 & $0$&$1$&$1$&$0$&$0$&$1$&$1$&$0$ & +108\\
$_1$&$1_1$&$0_1$&$0_1$&$1_1$&$0_1$&$1$&$0$&$0$ & -108\\
\hline
$1$&$0$&$0$&$0$&$0$&$0$&$0$&$0$&$0$&\\

\end{tabular}

\section{Ausdrücke}

Simple Sort

\begin{lstlisting}[language=C]
#include <stdio.h>

int data[] = {7,3,9,2,5};

int main(){
	int ige, iro; // entsprechende Pfeile unter den Zahlen auf Papier
	for (irt=0; irt<(5-1); irt++={
		for (ige = irt+1, ige<5, ige++){
			if (data[ige] < data[irt]){
				int tmp = data [ige];
				data[ige] = data[irt];
				
				data[irt] = tmp;
				// tauschen alternativ (ohne Zwischenspeichern): (^= ist XOR)
				// data[irt]^=data[ige];
				// data[ige]^=data[irt];
				// data[irt]^=data[ige];
			}
		}	
	}
	for (irt=0; irt<5; irt++={
		printf("%d ", data[irt]);
	}
	printf("\n");
	return 0;
}
\end{lstlisting}

Alphabetische Sortierung

\begin{lstlisting}[language=C]
#include <stdio.h>

#define N 10

//[10]: länge der Zeichenkette
char data[][10] = {"Max", "Huckebein", "Bolte", "Lempel", "Maecke", 
	"Helene", "Antonius", "Schlich", "Moritz", "Boeck"};

int main(){
	int ige, iro, ibl; // entspr. Pfeile unter den Zahlen auf Papier
	for (irt=0; irt<(N-1); irt++={
		for (ige = irt+1, ige<N, ige++){
			for (ibl = 0; data[irt][ibl] == data[ige][ibl] && 
				data[irt][ibl]!=0; ibl++){
				;
			}
			if(data[irt][ibl] > data[ige][ibl]){
				char tmp;
				// ibl muss nicht auf 0 gesetzt werden, vertauscht muss sowieso
				// erst ab dem ungleichen Zeichen getauscht werden
				for (/*ibl = 0*/; ibl<N ; ibl++){
					tmp = data[irt][ibl];
					data[irt][ibl] = data[ige][ibl];
					data[ige][ibl] = tmp;
					// alternativ wieder:
					// data[irt][ibl] ^= data[ige][ibl];
					// data[ige][ibl] ^= data[irt][ibl];
					// data[irt][ibl] ^= data[ige][ibl];
			}
		}	
	}
	for (irt=0; irt<N; irt++={
		printf("%d ", data[irt]);
	}
	printf("\n");
	return 0;
}
\end{lstlisting}

\section{Speicherklassen}
\begin{itemize}
\item Register: Prozessor-Register relativ schnell
\item Volatile: Variable wird immer im Hauptspeicher gespeichert (Gegenteil von Register)
\item Static: Liegt die Variable in einer Funktion, dann existiert sie über die gesamte Laufzeit des Programms (kann aber trotzdem nur innerhalb der Funktion verwendet werden). Liegt die Variable außerhalb einer Funktion, dann wird Variablennahme nur im aktuellen C-Quelltext verwendet (wenn sich Programm aus mehreren Quelltexten zusammengesetzt wird).
\item Extern: Gegenteil von Static außerhalb einer Funktion
\item Auto: automatische Variable. Wird beim Aufruf der Funktion, die die Variablendefinition enthält, angelegt. Bei jedem Funktionsaufruf neu. Wird vernichtet, wenn Funktion beendet ist.
\end{itemize}

\section{Funktionen}
\begin{lstlisting}[language=C]
int test(){...}
// gleich wie int main: Leerer Ausgabewert ist int (nicht void!)
test(){...}
// void: unbestimmter Ausgabewert bzw. kein Ausgabewert
void test(){...}
\end{lstlisting}

\paragraph{Übung} Sinus-Funktion: $x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}...$
\begin{lstlisting}[language=C]
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

double sinus(double x);

char vbuf[128];

int main(){
	double x,y;
	fgets(vbuf,128,stdin); 
	x = atof(vbuf);
	y = sinus(x);
	printf("sin(%lf): %lf\n",x,y);
	return 0;
}

double sinus(double x){
	int i=3, vz=-1;
	double erg=x, summand=x;
	while (summand> 0.00005){
		summand = summand * x * x/(i*(i+1));
		i += 2;
		erg += summand * vz;
		vz += -1;
	}
	return erg;
}

\end{lstlisting}

\section{Pointer}

\begin{lstlisting}[language=C]
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

char* upperstr(char* data){
	int i = 0;	
	while(data[i]!='\n'){	// (*data!='\n')
		// data[i]=toupper(data[i]);
		// Alternative zu toupper: 
		// A ist 0x41 = 0100 0001
		// a ist 0x61 = 0110 0001
		// also bloß ein Bit verschieben!
		if (data[i]>='a' && data[i]<='z'){
			data[i] &= ~(1<<5); 
			// 1101 1111, damit verunden=> alle werden negiert 0010 0000
			// &= Bitweise addition => invertierung von der 3. Stelle
		}
		// oder auch (entsprechend angepasst ohne i in while usw.)
		// *data = toupper(*data);
		// data++;
		i++;
	}
	return data;
}

char vbuf[128]

int main(){
	printf("Eingabe: ");
	fgets (vbuf,128,stdin);
	upperstr(vbuf);
	puts(vbuf);
	return 0;
}

\end{lstlisting}
Weiterführend:
\begin{lstlisting}[language=C]
#include <stdio.h>
#include <stdlib.h>

// Interpretation als Array
int mystrlen1(char *p){
	int i;
	for (i=0; p[i]!=0; i++);
	return i;
}

// Nutzen des Pointers
int mystrlen2(char *p){
	int count;
	while (*p++)
		count++;
	return count;
}

// Noch mehr nutzen des Pointers
int mystrlen3(char *p){
	char *px=p; // Pointer auf das erste Zeichen merken
	while (*p++); // Pointer hoch zählen (wenn letzte Stelle, ist *p++ 0, also false)
	return p-px-1; // (letzte Stelle)-(erste Stelle)-1
}

int intarr[] = {5,7,2,8,9};

// Interpretation als Array
int containsint(int n, int* pdata, int test){
	int i;
	for (i=0; i<n && pdata[i]!=test; i++);
	return pdata[i]==test;
}

// Nutzen der Pointer: *(pdata+i) ist das selbe wie pdata[i]
int containsInt2(int n, int* pdata, int test){
	while(*(pdata+--n)!= test && n!=0);
	return *(pdata+n)== test;
}

int mystrcmp(char* p1, char* p2){
	int i;
	for (i=0; p1[i]==p2[i] && p1[i]; i++);
	return p1[i]-p2[i];
}

int mystrcmp2(char* p1, char* p2){
	while (*p1-*p2 && *p1) p1++,p2++;
	return *p1-*p2;
}

int main (int argc, char* argv[]){
	int i, len;
	
	i=atoi(argv[1]);
	if(containsInt(sizeof intarr/sizeof(int), intarr, i))	puts("Enthalten");
	else																									puts("nicht Enthalten");
	
	if(mystrcmp(argv[1],argv[2])==0)	printf("%s gleich %s\n",argv[1],argv[2]);
	else															printf("%s ungleich %s\n",argv[1],argv[2]);
	
	for (i=0; i<argc; i++){
		puts(argv[i]);	// Ausgabe der Eingabeparameter
										// (wenn aufgerufen durch "./a.out e1 e2" werden
										// "./a.out", "e1" und "e2" ausgegeben)
		// Ausgabe des jeweils ersten Zeichens
		printf("%c\n".argv[i][0]);	// alternativ auch *argv[i]
		// argv[0] ist immer der Programmname
		
		for (i=0; i<argc; i++){
			len=mystrlen1(argv[i]);
			printf("len: %d\n", len);
		}
	}
	return 0;
}
\end{lstlisting}

\section{Benutzerdefinierte Datentypen}

Enum:

Aufzählungstyp (festgesetzte Bezeichnungen auf einen integer-Wert).\medskip\\
Struct:

Zusammenfassung von mehreren Komponenten (unterschiedliche eingebaute Dateitypen als un- intialisierte Variablen), die durch einen Namen beschrieben werden. Verwendung zur Modellierung eines Sachverhalts (wie im Beispiel Student mit seinen Eigenschaften).\medskip\\
Typedef:

Es wird ein synonymer Typname für einen existierenden Typnamen erstellt. So kann die Variable- ninitialisierung verkürzt werden (im Skript: struct tStudent$\rightarrow$tStud ).\medskip\\
Union:

Datensätze werden im Vergleich zum Struct übereinander geschrieben.

\newpage
%\printbibliography
\end{document}